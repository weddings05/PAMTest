
// Helper function to determine if it's an email login attempt
static int is_email_login(const char* input) {
    if (!input) return 0;
    
    // Count number of @ symbols
    int count = 0;
    const char* ptr = input;
    while ((ptr = strchr(ptr, '@')) != NULL) {
        count++;
        ptr++;
    }
    
    file_debug_log("%s: Checking if '%s' is email login (@ count: %d)", 
                   LOG_PREFIX, input, count);
    
    // If there are two @ symbols, it's likely an email login via SSH
    return (count == 2);
}

// Helper function to extract email from SSH input
static char* extract_email_from_ssh(const char* input) {
    if (!input) return NULL;

    char* copy = strdup(input);
    if (!copy) {
        file_debug_log("%s: Memory allocation failed in extract_email_from_ssh", LOG_PREFIX);
        return NULL;
    }

    char* first_at = strchr(copy, '@');
    if (first_at) {
        char* second_at = strchr(first_at + 1, '@');
        if (second_at) {
            *second_at = '\0';  // Terminate string at second @
            char* email = strdup(copy);
            free(copy);
            file_debug_log("%s: Extracted email: %s from SSH input: %s", 
                          LOG_PREFIX, email ? email : "NULL", input);
            return email;
        }
    }
    free(copy);
    return NULL;
}

// Extract local username from email
static char* extract_local_username(const char* email) {
    if (!email) return NULL;
    
    char* local_username = strdup(email);
    if (!local_username) {
        file_debug_log("%s: Memory allocation failed for username extraction", LOG_PREFIX);
        return NULL;
    }

    char* at_sign = strchr(local_username, '@');
    if (at_sign) {
        *at_sign = '\0';
    }
    
    file_debug_log("%s: Extracted local username '%s' from '%s'", 
                   LOG_PREFIX, local_username, email);
    return local_username;
}

// Check if local user exists
static int user_exists(const char* username) {
    if (!username) return 0;

    struct passwd *pw = getpwnam(username);
    int exists = (pw != NULL);
    
    file_debug_log("%s: Checking if user '%s' exists: %s", 
                   LOG_PREFIX, username, exists ? "yes" : "no");
    
    return exists;
}

// Authenticate with Okta
static int authenticate_with_okta(const char* username, const char* password) {
    if (!username || !password) {
        file_debug_log("%s: Username or password is NULL", LOG_PREFIX);
        return 0;
    }

    CURL *curl;
    CURLcode res;
    struct curl_response resp = {0};
    int auth_success = 0;
    long http_code = 0;

    file_debug_log("%s: Starting Okta authentication for user: %s", LOG_PREFIX, username);

    // Create JSON payload
    char *payload;
    size_t payload_size = strlen(username) + strlen(password) + 100;
    payload = malloc(payload_size);
    if (!payload) {
        file_debug_log("%s: Memory allocation failed for payload", LOG_PREFIX);
        return 0;
    }

    snprintf(payload, payload_size, 
             "{\"username\":\"%s\",\"password\":\"%s\"}", 
             username, password);

    file_debug_log("%s: Initializing CURL", LOG_PREFIX);
    curl = curl_easy_init();
    if (curl) {
        struct curl_slist *headers = NULL;
        headers = curl_slist_append(headers, "Accept: application/json");
        headers = curl_slist_append(headers, "Content-Type: application/json");

        file_debug_log("%s: Setting CURL options with URL: %s", LOG_PREFIX, config.api_url);
        
        curl_easy_setopt(curl, CURLOPT_URL, config.api_url);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload);
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&resp);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);
        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);

        file_debug_log("%s: Performing CURL request", LOG_PREFIX);
        res = curl_easy_perform(curl);
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        file_debug_log("%s: CURL request completed. Response code: %ld", LOG_PREFIX, http_code);

        if (res == CURLE_OK) {
            file_debug_log("%s: CURL request successful", LOG_PREFIX);
            if (http_code == 200 && resp.data) {
                file_debug_log("%s: Received response data: %s", LOG_PREFIX, resp.data ? resp.data : "NULL");
                
                if (resp.data && strstr(resp.data, "\"status\":\"SUCCESS\"")) {
                    auth_success = 1;
                    file_debug_log("%s: Authentication successful", LOG_PREFIX);
                } else {
                    file_debug_log("%s: Authentication failed - Status not SUCCESS", LOG_PREFIX);
                    if (resp.data) {
                        char *error = strstr(resp.data, "\"errorCode\"");
                        if (error) {
                            file_debug_log("%s: Error in response: %s", LOG_PREFIX, error);
                        }
                    }
                }
            } else {
                file_debug_log("%s: HTTP response code not 200 or no data received", LOG_PREFIX);
            }
        } else {
            file_debug_log("%s: CURL request failed: %s", LOG_PREFIX, curl_easy_strerror(res));
        }

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);
    } else {
        file_debug_log("%s: Failed to initialize CURL", LOG_PREFIX);
    }

    // Cleanup
    if (payload) {
        memset(payload, 0, strlen(payload));
        free(payload);
    }
    if (resp.data) {
        free(resp.data);
    }

    file_debug_log("%s: Authentication process completed. Success: %d", LOG_PREFIX, auth_success);
    return auth_success;
}
