static int select_mfa_factor(pam_handle_t* pamh, struct MFAFactors* factors) {
    const struct pam_conv* conv;
    struct pam_message msg;
    const struct pam_message* msg_ptr[1];
    struct pam_response* resp = NULL;
    
    int ret = pam_get_item(pamh, PAM_CONV, (const void**)&conv);
    if (ret != PAM_SUCCESS) {
        debug_log("Failed to get PAM conversation: %d", ret);
        return -1;
    }

    if (conv == NULL || conv->conv == NULL) {
        debug_log("PAM conversation is null");
        return -1;
    }

    // First create factor list string
    char factor_list[MAX_LINE * 2] = {0};
    for (int i = 0; i < factors->count; i++) {
        char factor_line[MAX_LINE];
        const char* display_type;
        
        // Simplify factor type display
        if (strcmp(factors->factors[i].type, "token:software:totp") == 0) {
            display_type = "Token";
        } else if (strcmp(factors->factors[i].type, "push") == 0) {
            display_type = "Push";
        } else {
            display_type = factors->factors[i].type;
        }
        
        snprintf(factor_line, sizeof(factor_line), 
                "  %d) %s via %s\n", 
                i + 1, 
                display_type, 
                factors->factors[i].provider);
        strcat(factor_list, factor_line);
    }

    // Create the complete prompt with formatted strings
    char options_prompt[MAX_LINE * 4] = {0};
    snprintf(options_prompt, sizeof(options_prompt),
             "Select MFA method:\n\n%sEnter choice (1-%d): ",
             factor_list,
             factors->count);

    debug_log("Displaying prompt:\n%s", options_prompt);

    // Set up the PAM conversation
    msg.msg_style = PAM_PROMPT_ECHO_ON;
    msg.msg = options_prompt;
    msg_ptr[0] = &msg;

    // Get user selection
    ret = conv->conv(1, msg_ptr, &resp, conv->appdata_ptr);
    if (ret != PAM_SUCCESS) {
        debug_log("Conversation failed: %d", ret);
        return -1;
    }

    if (resp == NULL || resp[0].resp == NULL) {
        debug_log("No response received");
        if (resp) free(resp);
        return -1;
    }

    // Process selection
    int selection = atoi(resp[0].resp) - 1;

    // Clean up
    memset(resp[0].resp, 0, strlen(resp[0].resp));
    free(resp[0].resp);
    free(resp);

    // Validate selection
    if (selection < 0 || selection >= factors->count) {
        debug_log("Invalid selection: %d", selection);
        return -1;
    }

    debug_log("Selected factor %d: %s via %s", 
              selection + 1,
              factors->factors[selection].type,
              factors->factors[selection].provider);

    return selection;
}
