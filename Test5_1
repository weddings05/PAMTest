
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <security/pam_modules.h>
#include <security/pam_ext.h>
#include <curl/curl.h>
#include <syslog.h>
#include <unistd.h>
#include <pwd.h>
#include <errno.h>
#include <time.h>
#include <ctype.h>

#define OKTA_API_URL "https://your-domain.okta.com/api/v1/authn"
#define MAX_USERNAME_LENGTH 256
#define MAX_PASSWORD_LENGTH 256
#define CONFIG_FILE "/etc/okta_pam.conf"
#define LOG_PREFIX "PAM_OKTA"
#define DEBUG_FILE "/var/log/okta_pam_debug.log"
#define MAX_RESPONSE_SIZE 4096

// Structure to store CURL response
struct curl_response {
    char *data;
    size_t size;
};

// Structure to store configuration
struct okta_config {
    char api_url[256];
    int debug;
};

// Global configuration
static struct okta_config config = {
    .api_url = OKTA_API_URL,
    .debug = 1
};

// Debug logging function
static void file_debug_log(const char *format, ...) {
    FILE *f = fopen(DEBUG_FILE, "a");
    if (f) {
        va_list args;
        time_t now = time(NULL);
        char timestamp[64];
        strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
        
        fprintf(f, "[%s] ", timestamp);
        va_start(args, format);
        vfprintf(f, format, args);
        va_end(args);
        fprintf(f, "\n");
        fflush(f);
        fclose(f);
    }
}

// Load configuration from file
static void load_config(void) {
    FILE *fp = fopen(CONFIG_FILE, "r");
    if (!fp) {
        file_debug_log("%s: Could not open config file %s: %s", 
                      LOG_PREFIX, CONFIG_FILE, strerror(errno));
        return;
    }

    char line[512];
    while (fgets(line, sizeof(line), fp)) {
        char *key = strtok(line, "=");
        char *value = strtok(NULL, "\n");
        
        if (key && value) {
            while (*key && isspace(*key)) key++;
            while (*value && isspace(*value)) value++;
            
            if (strcmp(key, "api_url") == 0) {
                strncpy(config.api_url, value, sizeof(config.api_url) - 1);
            } else if (strcmp(key, "debug") == 0) {
                config.debug = atoi(value);
            }
        }
    }
    fclose(fp);
}

// CURL write callback
static size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    struct curl_response *resp = (struct curl_response *)userp;

    file_debug_log("%s: Received %zu bytes of data", LOG_PREFIX, realsize);

    if (resp->size + realsize >= MAX_RESPONSE_SIZE) {
        file_debug_log("%s: Response too large", LOG_PREFIX);
        return 0;
    }

    char *ptr = realloc(resp->data, resp->size + realsize + 1);
    if (!ptr) {
        file_debug_log("%s: Memory allocation failed in write_callback", LOG_PREFIX);
        return 0;
    }

    resp->data = ptr;
    memcpy(&(resp->data[resp->size]), contents, realsize);
    resp->size += realsize;
    resp->data[resp->size] = 0;

    return realsize;
}
