Here's the updated PAM module code without using any JSON libraries. It uses simple string manipulation for the HTTP request:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <security/pam_modules.h>
#include <security/pam_ext.h>
#include <curl/curl.h>
#include <syslog.h>
#include <unistd.h>
#include <pwd.h>
#include <errno.h>

#define OKTA_API_URL "https://your-domain.okta.com/api/v1/authn"
#define MAX_USERNAME_LENGTH 256
#define MAX_PASSWORD_LENGTH 256
#define CONFIG_FILE "/etc/okta_pam.conf"
#define LOG_PREFIX "PAM_OKTA"

// Structure to store CURL response
struct curl_response {
    char *data;
    size_t size;
};

// Structure to store configuration
struct okta_config {
    char api_url[256];
    int debug;
};

// Global configuration
static struct okta_config config = {
    .api_url = OKTA_API_URL,
    .debug = 0
};

// Debug logging function
static void debug_log(const char *format, ...) {
    if (config.debug) {
        va_list args;
        va_start(args, format);
        vsyslog(LOG_AUTH|LOG_DEBUG, format, args);
        va_end(args);
    }
}

// Load configuration from file
static void load_config(void) {
    FILE *fp = fopen(CONFIG_FILE, "r");
    if (!fp) {
        syslog(LOG_AUTH|LOG_WARNING, "%s: Could not open config file %s: %s", 
               LOG_PREFIX, CONFIG_FILE, strerror(errno));
        return;
    }

    char line[512];
    while (fgets(line, sizeof(line), fp)) {
        char *key = strtok(line, "=");
        char *value = strtok(NULL, "\n");
        
        if (key && value) {
            // Remove whitespace
            while (*key && isspace(*key)) key++;
            while (*value && isspace(*value)) value++;
            
            if (strcmp(key, "api_url") == 0) {
                strncpy(config.api_url, value, sizeof(config.api_url) - 1);
            } else if (strcmp(key, "debug") == 0) {
                config.debug = atoi(value);
            }
        }
    }
    fclose(fp);
}

// CURL write callback
static size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    struct curl_response *resp = (struct curl_response *)userp;

    char *ptr = realloc(resp->data, resp->size + realsize + 1);
    if (!ptr) {
        syslog(LOG_AUTH|LOG_ERR, "%s: Memory allocation failed", LOG_PREFIX);
        return 0;
    }

    resp->data = ptr;
    memcpy(&(resp->data[resp->size]), contents, realsize);
    resp->size += realsize;
    resp->data[resp->size] = 0;

    return realsize;
}

// Extract local username from email
static char* extract_local_username(const char* email) {
    if (!email) return NULL;
    
    char* local_username = strdup(email);
    if (!local_username) {
        syslog(LOG_AUTH|LOG_ERR, "%s: Memory allocation failed", LOG_PREFIX);
        return NULL;
    }

    char* at_sign = strchr(local_username, '@');
    if (at_sign) {
        *at_sign = '\0';
    }
    
    debug_log("%s: Extracted local username '%s' from '%s'", LOG_PREFIX, local_username, email);
    return local_username;
}

// Check if local user exists
static int user_exists(const char* username) {
    if (!username) return 0;

    struct passwd *pw = getpwnam(username);
    int exists = (pw != NULL);
    
    debug_log("%s: Checking if user '%s' exists: %s", 
              LOG_PREFIX, username, exists ? "yes" : "no");
    
    return exists;
}

// Simple string search function
static int str_contains(const char *haystack, const char *needle) {
    return strstr(haystack, needle) != NULL;
}

// Authenticate with Okta using simple string manipulation
static int authenticate_with_okta(const char* username, const char* password) {
    if (!username || !password) return 0;

    CURL *curl;
    CURLcode res;
    struct curl_response resp = {0};
    int auth_success = 0;
    long http_code = 0;

    debug_log("%s: Attempting Okta authentication for user '%s'", LOG_PREFIX, username);

    // Create JSON payload manually
    char *payload;
    size_t payload_size = strlen(username) + strlen(password) + 100;
    payload = malloc(payload_size);
    if (!payload) {
        syslog(LOG_AUTH|LOG_ERR, "%s: Memory allocation failed", LOG_PREFIX);
        return 0;
    }

    snprintf(payload, payload_size, 
             "{\"username\":\"%s\",\"password\":\"%s\"}", 
             username, password);

    curl = curl_easy_init();
    if (curl) {
        struct curl_slist *headers = NULL;
        headers = curl_slist_append(headers, "Accept: application/json");
        headers = curl_slist_append(headers, "Content-Type: application/json");

        curl_easy_setopt(curl, CURLOPT_URL, config.api_url);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload);
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&resp);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);

        res = curl_easy_perform(curl);
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        if (res == CURLE_OK && http_code == 200 && resp.data) {
            // Simple check for success status in response
            if (str_contains(resp.data, "\"status\":\"SUCCESS\"")) {
                auth_success = 1;
                debug_log("%s: Okta authentication successful", LOG_PREFIX);
            } else {
                debug_log("%s: Okta authentication failed", LOG_PREFIX);
            }
        } else {
            syslog(LOG_AUTH|LOG_ERR, "%s: Okta API call failed: %s (HTTP %ld)", 
                   LOG_PREFIX, curl_easy_strerror(res), http_code);
        }

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);
    }

    // Cleanup
    if (payload) {
        memset(payload, 0, strlen(payload)); // Clear sensitive data
        free(payload);
    }
    if (resp.data) {
        free(resp.data);
    }

    return auth_success;
}

PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    const char *username = NULL;
    char *okta_password = NULL;
    int retval;

    // Load configuration
    load_config();

    // Initialize logging
    openlog("pam_okta", LOG_PID, LOG_AUTH);

    // Get username
    retval = pam_get_user(pamh, &username, NULL);
    if (retval != PAM_SUCCESS) {
        syslog(LOG_AUTH|LOG_ERR, "%s: Failed to get username", LOG_PREFIX);
        return retval;
    }

    debug_log("%s: Processing authentication for user: %s", LOG_PREFIX, username);

    // Extract local username if it's an email
    char *local_username = extract_local_username(username);
    if (!local_username) {
        return PAM_SYSTEM_ERR;
    }

    // Check if local user exists
    if (!user_exists(local_username)) {
        syslog(LOG_AUTH|LOG_ERR, "%s: Local user %s does not exist", LOG_PREFIX, local_username);
        free(local_username);
        return PAM_USER_UNKNOWN;
    }

    // If username contains @, try Okta authentication
    if (strchr(username, '@')) {
        // Get Okta password
        const char *prompt = "Okta Password: ";
        char *resp = NULL;
        retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &resp, "%s", prompt);
        
        if (retval != PAM_SUCCESS || !resp) {
            syslog(LOG_AUTH|LOG_ERR, "%s: Failed to get Okta password", LOG_PREFIX);
            free(local_username);
            return PAM_AUTH_ERR;
        }

        okta_password = strdup(resp);
        free(resp);

        if (!okta_password) {
            syslog(LOG_AUTH|LOG_ERR, "%s: Memory allocation failed", LOG_PREFIX);
            free(local_username);
            return PAM_SYSTEM_ERR;
        }

        debug_log("%s: Attempting Okta authentication for %s", LOG_PREFIX, username);

        if (authenticate_with_okta(username, okta_password)) {
            syslog(LOG_AUTH|LOG_INFO, "%s: Okta authentication successful for %s", LOG_PREFIX, username);
            
            // Set local username for the session
            pam_set_item(pamh, PAM_USER, local_username);
            
            // Cleanup
            memset(okta_password, 0, strlen(okta_password));
            free(okta_password);
            free(local_username);
            
            return PAM_SUCCESS;
        }

        // Cleanup
        memset(okta_password, 0, strlen(okta_password));
        free(okta_password);
        syslog(LOG_AUTH|LOG_INFO, "%s: Okta authentication failed, falling back to local authentication", LOG_PREFIX);
    }

    free(local_username);
    return PAM_AUTH_ERR;
}

PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}
```

And here's the simplified Makefile:

```makefile
CC=gcc
CFLAGS=-fPIC -fno-stack-protector -Wall
LDFLAGS=-shared
LIBS=-lpam -lcurl

TARGET=pam_okta.so
SOURCES=pam_okta.c

all: $(TARGET)

$(TARGET): $(SOURCES)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $(TARGET) $(SOURCES) $(LIBS)

install: $(TARGET)
	install -d /lib64/security
	install -m 755 $(TARGET) /lib64/security/
	install -m 600 okta_pam.conf /etc/okta_pam.conf

clean:
	rm -f $(TARGET)
```

Install dependencies:
```bash
# For RHEL/CentOS
sudo yum install gcc make pam-devel curl-devel

# For Ubuntu/Debian
sudo apt-get install gcc make libpam0g-dev libcurl4-openssl-dev
```

Key changes in this version:
1. Removed all JSON library dependencies
2. Uses simple string manipulation for JSON payload
3. Simple string search for response parsing
4. Simplified build process
5. Maintains all the same functionality

The configuration files and usage remain the same as before:

1. Create config file:
```bash
sudo vi /etc/okta_pam.conf
```
```ini
api_url=https://your-domain.okta.com/api/v1/authn
debug=1
```

2. Configure PAM (`/etc/pam.d/sshd`):
```
auth        [success=1 default=ignore]     pam_okta.so
auth        required     pam_sepermit.so
auth        substack     password-auth
auth        include      postlogin
```

3. Build and install:
```bash
cd /usr/src
sudo make
sudo make install
sudo systemctl restart sshd
```

4. Test:
```bash
ssh user@example.com@hostname
```

This version is simpler to build and maintain while providing the same functionality:
- Okta authentication with fallback to local auth
- Username mapping from email to local user
- Secure password handling
- Detailed logging
- Configuration file support​​​​​​​​​​​​​​​​
