// Add these new structures after your existing ones
struct OIDCAccess {
    char client_id[MAX_LINE];
    char allowed;
};

// Add this new function to check OIDC access
static int check_oidc_access(CURL* curl, const char* username, struct OktaConfig* config) {
    CURLcode res;
    struct MemoryStruct chunk;
    chunk.memory = malloc(1);
    chunk.size = 0;

    // Build the URL for checking app assignments
    char url[MAX_LINE * 2];
    snprintf(url, sizeof(url), 
             "%s/api/v1/apps?filter=user.id+eq+\"%s\"", 
             config->issuer, username);

    debug_log("Checking OIDC access for user %s", username);
    debug_log("OIDC check URL: %s", url);

    struct curl_slist* headers = NULL;
    headers = curl_slist_append(headers, "Accept: application/json");
    headers = curl_slist_append(headers, "Content-Type: application/json");
    
    // Add authorization header with API token
    char auth_header[MAX_LINE];
    snprintf(auth_header, sizeof(auth_header), 
             "Authorization: SSWS %s", config->api_token);
    headers = curl_slist_append(headers, auth_header);

    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);

    res = curl_easy_perform(curl);
    if (res != CURLE_OK) {
        debug_log("Failed to check OIDC access: %s", curl_easy_strerror(res));
        free(chunk.memory);
        curl_slist_free_all(headers);
        return 0;  // Access denied
    }

    debug_log("OIDC apps response: %s", chunk.memory);

    // Check if the required client_id is in the response
    int has_access = (strstr(chunk.memory, config->required_client_id) != NULL);
    debug_log("User %s %s access to required OIDC app", 
              username, has_access ? "has" : "does not have");

    free(chunk.memory);
    curl_slist_free_all(headers);
    return has_access;
}

// Modify your authenticate_with_okta function to include OIDC check
static int authenticate_with_okta(pam_handle_t* pamh, const char* username, 
                                const char* password, struct OktaConfig* config) {
    // ... your existing authentication code ...

    // After successful MFA verification, check OIDC access
    if (ret == PAM_SUCCESS) {
        debug_log("Authentication successful, checking OIDC access");
        
        if (!check_oidc_access(curl, username, config)) {
            debug_log("User not authorized for required OIDC application");
            ret = PAM_AUTH_ERR;
            goto cleanup;
        }
        
        debug_log("OIDC access check passed");
    }

    // ... rest of your function ...
}

// Add these fields to your OktaConfig struct
struct OktaConfig {
    // ... your existing fields ...
    char api_token[MAX_LINE];
    char required_client_id[MAX_LINE];
    char issuer[MAX_LINE];
};

// Modify your read_config function to read the new fields
static int read_config(struct OktaConfig* config) {
    // ... your existing config reading code ...

    char line[MAX_LINE];
    while (fgets(line, sizeof(line), fp)) {
        if (line[0] == '#' || line[0] == '\n') continue;
        
        char* key = strtok(line, "=");
        char* value = strtok(NULL, "\n");
        
        if (key && value) {
            while (*value == ' ') value++;
            
            if (strcmp(key, "api_token") == 0)
                strncpy(config->api_token, value, MAX_LINE - 1);
            else if (strcmp(key, "required_client_id") == 0)
                strncpy(config->required_client_id, value, MAX_LINE - 1);
            else if (strcmp(key, "issuer") == 0)
                strncpy(config->issuer, value, MAX_LINE - 1);
            // ... your existing config options ...
        }
    }

    // Validate required fields
    if (!config->api_token[0] || !config->required_client_id[0] || !config->issuer[0]) {
        debug_log("Missing required OIDC configuration");
        return -1;
    }

    return 0;
}
