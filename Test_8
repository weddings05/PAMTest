#define PAM_SM_AUTH
#include <security/pam_modules.h>
#include <security/pam_ext.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <pthread.h>
#include <microhttpd.h>
#include <sys/wait.h>
#include <time.h>
#include <errno.h>
#include <syslog.h>

#define PORT 8000
#define CONFIG_FILE "/etc/pam_okta.conf"
#define MAX_BUFFER 4096
#define DEBUG_FILE "/var/log/pam_okta.log"

struct auth_context {
    char *auth_code;
    struct MHD_Daemon *daemon;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int auth_completed;
};

struct config {
    char okta_domain[256];
    char client_id[256];
    char client_secret[256];
    char redirect_uri[256];
};

static struct config conf;

struct string {
    char *ptr;
    size_t len;
};

static void log_message(int priority, const char *format, ...) {
    va_list args;
    va_start(args, format);
    openlog("pam_okta", LOG_PID, LOG_AUTHPRIV);
    vsyslog(priority, format, args);
    closelog();
    va_end(args);

    FILE *f = fopen(DEBUG_FILE, "a");
    if (f) {
        time_t now = time(NULL);
        char timestamp[64];
        strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
        fprintf(f, "[%s] ", timestamp);
        va_start(args, format);
        vfprintf(f, format, args);
        fprintf(f, "\n");
        va_end(args);
        fclose(f);
    }
}

void init_string(struct string *s) {
    s->len = 0;
    s->ptr = malloc(s->len + 1);
    if (s->ptr == NULL) {
        log_message(LOG_ERR, "Failed to allocate memory");
        exit(1);
    }
    s->ptr[0] = '\0';
}

size_t writefunc(void *ptr, size_t size, size_t nmemb, struct string *s) {
    size_t new_len = s->len + size * nmemb;
    s->ptr = realloc(s->ptr, new_len + 1);
    if (s->ptr == NULL) {
        log_message(LOG_ERR, "Failed to reallocate memory");
        exit(1);
    }
    memcpy(s->ptr + s->len, ptr, size * nmemb);
    s->ptr[new_len] = '\0';
    s->len = new_len;
    return size * nmemb;
}

static int handle_callback(void *cls,
                         struct MHD_Connection *connection,
                         const char *url,
                         const char *method,
                         const char *version,
                         const char *upload_data,
                         size_t *upload_data_size,
                         void **con_cls) {
    struct auth_context *context = (struct auth_context *)cls;
    
    if (strcmp(method, "GET") != 0) {
        return MHD_NO;
    }

    const char *code = MHD_lookup_connection_value(connection, MHD_GET_ARGUMENT_KIND, "code");
    if (code) {
        log_message(LOG_INFO, "Received authorization code");
        pthread_mutex_lock(&context->mutex);
        context->auth_code = strdup(code);
        context->auth_completed = 1;
        pthread_cond_signal(&context->cond);
        pthread_mutex_unlock(&context->mutex);

        const char *page = "<html><body><script>window.close();</script>Authentication successful! You can close this window.</body></html>";
        struct MHD_Response *response = MHD_create_response_from_buffer(strlen(page),
                                                                      (void *)page,
                                                                      MHD_RESPMEM_PERSISTENT);
        int ret = MHD_queue_response(connection, MHD_HTTP_OK, response);
        MHD_destroy_response(response);
        return ret;
    }

    return MHD_NO;
}

static int load_config() {
    FILE *fp = fopen(CONFIG_FILE, "r");
    if (!fp) {
        log_message(LOG_ERR, "Failed to open config file: %s", CONFIG_FILE);
        return -1;
    }

    char line[256];
    while (fgets(line, sizeof(line), fp)) {
        char *key = strtok(line, "=");
        char *value = strtok(NULL, "\n");
        if (key && value) {
            while (*value == ' ') value++;
            char *end = value + strlen(value) - 1;
            while (end > value && (*end == ' ' || *end == '\n')) *end-- = '\0';
            
            if (strcmp(key, "okta_domain") == 0) {
                strncpy(conf.okta_domain, value, sizeof(conf.okta_domain) - 1);
            } else if (strcmp(key, "client_id") == 0) {
                strncpy(conf.client_id, value, sizeof(conf.client_id) - 1);
            } else if (strcmp(key, "client_secret") == 0) {
                strncpy(conf.client_secret, value, sizeof(conf.client_secret) - 1);
            } else if (strcmp(key, "redirect_uri") == 0) {
                strncpy(conf.redirect_uri, value, sizeof(conf.redirect_uri) - 1);
            }
        }
    }
    fclose(fp);
    return 0;
}

static int verify_okta_token(const char *auth_code, const char *username) {
    CURL *curl;
    CURLcode res;
    struct string s;
    init_string(&s);
    
    curl = curl_easy_init();
    if (!curl) {
        log_message(LOG_ERR, "Failed to initialize CURL");
        return PAM_AUTH_ERR;
    }

    char post_fields[MAX_BUFFER];
    snprintf(post_fields, sizeof(post_fields),
             "grant_type=authorization_code&code=%s&redirect_uri=%s&client_id=%s&client_secret=%s",
             auth_code, conf.redirect_uri, conf.client_id, conf.client_secret);

    char url[MAX_BUFFER];
    snprintf(url, sizeof(url), "https://%s/oauth2/v1/token", conf.okta_domain);

    log_message(LOG_INFO, "Requesting token from Okta");
    
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_fields);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writefunc);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &s);

    res = curl_easy_perform(curl);
    curl_easy_cleanup(curl);

    if (res != CURLE_OK) {
        log_message(LOG_ERR, "Token request failed: %s", curl_easy_strerror(res));
        free(s.ptr);
        return PAM_AUTH_ERR;
    }

    // Check if we received an access token
    if (strstr(s.ptr, "access_token") == NULL) {
        log_message(LOG_ERR, "No access token in response");
        free(s.ptr);
        return PAM_AUTH_ERR;
    }

    free(s.ptr);
    log_message(LOG_INFO, "Successfully validated token for user: %s", username);
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    const char *username;
    int ret;

    log_message(LOG_INFO, "Starting Okta authentication process");

    if (load_config() != 0) {
        log_message(LOG_ERR, "Failed to load configuration");
        return PAM_IGNORE;
    }

    ret = pam_get_user(pamh, &username, NULL);
    if (ret != PAM_SUCCESS) {
        log_message(LOG_ERR, "Failed to get username");
        return PAM_IGNORE;
    }

    struct auth_context context = {0};
    pthread_mutex_init(&context.mutex, NULL);
    pthread_cond_init(&context.cond, NULL);

    // Start the local server for callback
    context.daemon = MHD_start_daemon(MHD_USE_THREAD_PER_CONNECTION,
                                    PORT,
                                    NULL,
                                    NULL,
                                    &handle_callback,
                                    &context,
                                    MHD_OPTION_END);

    if (!context.daemon) {
        log_message(LOG_ERR, "Failed to start HTTP daemon");
        return PAM_IGNORE;
    }

    // Launch browser for authentication
    char auth_url[MAX_BUFFER];
    snprintf(auth_url, sizeof(auth_url),
             "xdg-open 'https://%s/oauth2/v1/authorize?client_id=%s&response_type=code"
             "&scope=openid%%20profile&redirect_uri=%s&state=state123&login_hint=%s'",
             conf.okta_domain, conf.client_id, conf.redirect_uri, username);

    log_message(LOG_INFO, "Launching browser for authentication");
    system(auth_url);

    // Wait for authentication completion
    pthread_mutex_lock(&context.mutex);
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    ts.tv_sec += 300; // 5-minute timeout
    
    while (!context.auth_completed) {
        if (pthread_cond_timedwait(&context.cond, &context.mutex, &ts) == ETIMEDOUT) {
            log_message(LOG_WARNING, "Authentication timed out");
            pthread_mutex_unlock(&context.mutex);
            MHD_stop_daemon(context.daemon);
            return PAM_IGNORE;
        }
    }
    pthread_mutex_unlock(&context.mutex);

    log_message(LOG_INFO, "Received authentication response");
    MHD_stop_daemon(context.daemon);

    // Verify the token
    ret = verify_okta_token(context.auth_code, username);
    free(context.auth_code);

    pthread_mutex_destroy(&context.mutex);
    pthread_cond_destroy(&context.cond);

    if (ret != PAM_SUCCESS) {
        log_message(LOG_WARNING, "Okta authentication failed, allowing fallback");
        return PAM_IGNORE;
    }

    log_message(LOG_INFO, "Okta authentication successful");
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}
