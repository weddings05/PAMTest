static int parse_mfa_factors(const char* json_str, struct MFAFactors* factors) {
    debug_log("Starting to parse MFA factors");
    factors->count = 0;

    // Log the full response for debugging
    debug_log("Full JSON response: %s", json_str);

    // First find _embedded
    char* embedded = strstr(json_str, "\"_embedded\":");
    if (!embedded) {
        debug_log("No _embedded section found");
        return -1;
    }
    debug_log("Found _embedded section");

    // Find factors array
    char* factors_start = strstr(embedded, "\"factors\":[");
    if (!factors_start) {
        debug_log("No factors array found");
        return -1;
    }
    debug_log("Found factors array");

    // Move pointer to start of array content
    char* current = factors_start + strlen("\"factors\":[");

    // Process each factor
    while (*current != '\0' && *current != ']' && factors->count < MAX_FACTORS) {
        // Find start of factor object
        while (*current != '{' && *current != ']' && *current != '\0') {
            current++;
        }

        if (*current != '{') break;

        // Extract the entire factor object
        char factor_obj[MAX_LINE * 4] = {0};
        int brace_count = 1;
        int obj_pos = 0;
        current++; // Skip the opening brace
        factor_obj[obj_pos++] = '{';

        while (brace_count > 0 && *current != '\0' && obj_pos < (MAX_LINE * 4 - 1)) {
            factor_obj[obj_pos++] = *current;
            if (*current == '{') brace_count++;
            if (*current == '}') brace_count--;
            current++;
        }
        factor_obj[obj_pos] = '\0';

        debug_log("Processing factor object: %s", factor_obj);

        // Find each field individually
        char* id = strstr(factor_obj, "\"id\":\"");
        char* type = strstr(factor_obj, "\"factorType\":\"");
        char* provider = strstr(factor_obj, "\"provider\":\"");

        if (id && type && provider) {
            // Extract ID
            id += 6; // Skip "id":""
            char* id_end = strchr(id, '"');
            if (id_end) {
                size_t len = id_end - id;
                if (len < MAX_LINE) {
                    strncpy(factors->factors[factors->count].id, id, len);
                    factors->factors[factors->count].id[len] = '\0';
                }
            }

            // Extract Type
            type += 13; // Skip "factorType":""
            char* type_end = strchr(type, '"');
            if (type_end) {
                size_t len = type_end - type;
                if (len < MAX_LINE) {
                    strncpy(factors->factors[factors->count].type, type, len);
                    factors->factors[factors->count].type[len] = '\0';
                }
            }

            // Extract Provider
            provider += 11; // Skip "provider":""
            char* provider_end = strchr(provider, '"');
            if (provider_end) {
                size_t len = provider_end - provider;
                if (len < MAX_LINE) {
                    strncpy(factors->factors[factors->count].provider, provider, len);
                    factors->factors[factors->count].provider[len] = '\0';
                }
            }

            debug_log("Successfully parsed factor %d:", factors->count + 1);
            debug_log("  ID: %s", factors->factors[factors->count].id);
            debug_log("  Type: %s", factors->factors[factors->count].type);
            debug_log("  Provider: %s", factors->factors[factors->count].provider);

            factors->count++;
        } else {
            debug_log("Missing required fields - id:%s, type:%s, provider:%s", 
                     id ? "found" : "missing",
                     type ? "found" : "missing",
                     provider ? "found" : "missing");
        }
    }

    debug_log("Found total of %d factors", factors->count);
    return factors->count > 0 ? 0 : -1;
}

static int select_mfa_factor(pam_handle_t* pamh, struct MFAFactors* factors) {
    char prompt[MAX_LINE * 3];
    char* response = NULL;
    
    debug_log("Preparing factor selection prompt for %d factors", factors->count);
    
    snprintf(prompt, sizeof(prompt), "Select MFA method:\n");
    for (int i = 0; i < factors->count; i++) {
        char factor_desc[MAX_LINE];
        snprintf(factor_desc, sizeof(factor_desc), 
                "%d) %s via %s\n", 
                i + 1, 
                factors->factors[i].type[0] ? factors->factors[i].type : "unknown",
                factors->factors[i].provider[0] ? factors->factors[i].provider : "unknown");
        strncat(prompt, factor_desc, sizeof(prompt) - strlen(prompt) - 1);
        
        debug_log("Added factor option: %s", factor_desc);
    }
    
    int ret = prompt_user(pamh, PAM_PROMPT_ECHO_ON, prompt, &response);
    if (ret != PAM_SUCCESS || !response) {
        debug_log("Failed to get factor selection response");
        return -1;
    }
    
    int selection = atoi(response) - 1;
    free(response);
    
    if (selection < 0 || selection >= factors->count) {
        debug_log("Invalid factor selection: %d (valid range: 0-%d)", 
                 selection, factors->count - 1);
        return -1;
    }
    
    debug_log("Selected factor %d: %s via %s", 
              selection + 1,
              factors->factors[selection].type,
              factors->factors[selection].provider);
    
    return selection;
}

