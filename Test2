Here's the updated PAM module code using json-glib instead of json-c:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <security/pam_modules.h>
#include <security/pam_ext.h>
#include <curl/curl.h>
#include <glib.h>
#include <json-glib/json-glib.h>
#include <syslog.h>
#include <unistd.h>
#include <pwd.h>
#include <errno.h>

#define OKTA_API_URL "https://your-domain.okta.com/api/v1/authn"
#define MAX_USERNAME_LENGTH 256
#define MAX_PASSWORD_LENGTH 256
#define CONFIG_FILE "/etc/okta_pam.conf"
#define LOG_PREFIX "PAM_OKTA"

// Structure to store CURL response
struct curl_response {
    char *data;
    size_t size;
};

// Structure to store configuration
struct okta_config {
    char api_url[256];
    int debug;
};

// Global configuration
static struct okta_config config = {
    .api_url = OKTA_API_URL,
    .debug = 0
};

// Debug logging function
static void debug_log(const char *format, ...) {
    if (config.debug) {
        va_list args;
        va_start(args, format);
        vsyslog(LOG_AUTH|LOG_DEBUG, format, args);
        va_end(args);
    }
}

// Load configuration from file
static void load_config(void) {
    FILE *fp = fopen(CONFIG_FILE, "r");
    if (!fp) {
        syslog(LOG_AUTH|LOG_WARNING, "%s: Could not open config file %s: %s", 
               LOG_PREFIX, CONFIG_FILE, strerror(errno));
        return;
    }

    char line[512];
    while (fgets(line, sizeof(line), fp)) {
        char *key = strtok(line, "=");
        char *value = strtok(NULL, "\n");
        
        if (key && value) {
            // Remove whitespace
            while (*key && isspace(*key)) key++;
            while (*value && isspace(*value)) value++;
            
            if (strcmp(key, "api_url") == 0) {
                strncpy(config.api_url, value, sizeof(config.api_url) - 1);
            } else if (strcmp(key, "debug") == 0) {
                config.debug = atoi(value);
            }
        }
    }
    fclose(fp);
}

// CURL write callback
static size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    struct curl_response *resp = (struct curl_response *)userp;

    char *ptr = realloc(resp->data, resp->size + realsize + 1);
    if (!ptr) {
        syslog(LOG_AUTH|LOG_ERR, "%s: Memory allocation failed", LOG_PREFIX);
        return 0;
    }

    resp->data = ptr;
    memcpy(&(resp->data[resp->size]), contents, realsize);
    resp->size += realsize;
    resp->data[resp->size] = 0;

    return realsize;
}

// Extract local username from email
static char* extract_local_username(const char* email) {
    if (!email) return NULL;
    
    char* local_username = strdup(email);
    if (!local_username) {
        syslog(LOG_AUTH|LOG_ERR, "%s: Memory allocation failed", LOG_PREFIX);
        return NULL;
    }

    char* at_sign = strchr(local_username, '@');
    if (at_sign) {
        *at_sign = '\0';
    }
    
    debug_log("%s: Extracted local username '%s' from '%s'", LOG_PREFIX, local_username, email);
    return local_username;
}

// Check if local user exists
static int user_exists(const char* username) {
    if (!username) return 0;

    struct passwd *pw = getpwnam(username);
    int exists = (pw != NULL);
    
    debug_log("%s: Checking if user '%s' exists: %s", 
              LOG_PREFIX, username, exists ? "yes" : "no");
    
    return exists;
}

// Authenticate with Okta using json-glib
static int authenticate_with_okta(const char* username, const char* password) {
    if (!username || !password) return 0;

    CURL *curl;
    CURLcode res;
    struct curl_response resp = {0};
    int auth_success = 0;
    long http_code = 0;

    debug_log("%s: Attempting Okta authentication for user '%s'", LOG_PREFIX, username);

    // Create JSON payload using json-glib
    JsonBuilder *builder = json_builder_new();
    json_builder_begin_object(builder);
    json_builder_set_member_name(builder, "username");
    json_builder_add_string_value(builder, username);
    json_builder_set_member_name(builder, "password");
    json_builder_add_string_value(builder, password);
    json_builder_end_object(builder);

    JsonGenerator *gen = json_generator_new();
    JsonNode *root = json_builder_get_root(builder);
    json_generator_set_root(gen, root);
    gchar *json_string = json_generator_to_data(gen, NULL);

    curl = curl_easy_init();
    if (curl) {
        struct curl_slist *headers = NULL;
        headers = curl_slist_append(headers, "Accept: application/json");
        headers = curl_slist_append(headers, "Content-Type: application/json");

        curl_easy_setopt(curl, CURLOPT_URL, config.api_url);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_string);
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&resp);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);

        res = curl_easy_perform(curl);
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        if (res == CURLE_OK && http_code == 200 && resp.data) {
            JsonParser *parser = json_parser_new();
            GError *error = NULL;

            if (json_parser_load_from_data(parser, resp.data, -1, &error)) {
                JsonNode *root_node = json_parser_get_root(parser);
                JsonObject *obj = json_node_get_object(root_node);
                JsonNode *status_node = json_object_get_member(obj, "status");

                if (status_node && JSON_NODE_HOLDS_VALUE(status_node)) {
                    const gchar *status = json_node_get_string(status_node);
                    auth_success = (g_strcmp0(status, "SUCCESS") == 0);
                    debug_log("%s: Okta authentication status: %s", LOG_PREFIX, status);
                }
            } else {
                syslog(LOG_AUTH|LOG_ERR, "%s: JSON parsing error: %s", 
                       LOG_PREFIX, error->message);
                g_error_free(error);
            }

            g_object_unref(parser);
        } else {
            syslog(LOG_AUTH|LOG_ERR, "%s: Okta API call failed: %s (HTTP %ld)", 
                   LOG_PREFIX, curl_easy_strerror(res), http_code);
        }

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);
    }

    // Cleanup
    g_free(json_string);
    json_node_free(root);
    g_object_unref(gen);
    g_object_unref(builder);

    if (resp.data) {
        free(resp.data);
    }

    return auth_success;
}

// PAM functions remain the same
PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    const char *username = NULL;
    char *okta_password = NULL;
    int retval;

    // Load configuration
    load_config();

    // Initialize logging
    openlog("pam_okta", LOG_PID, LOG_AUTH);

    // Get username
    retval = pam_get_user(pamh, &username, NULL);
    if (retval != PAM_SUCCESS) {
        syslog(LOG_AUTH|LOG_ERR, "%s: Failed to get username", LOG_PREFIX);
        return retval;
    }

    debug_log("%s: Processing authentication for user: %s", LOG_PREFIX, username);

    // Extract local username if it's an email
    char *local_username = extract_local_username(username);
    if (!local_username) {
        return PAM_SYSTEM_ERR;
    }

    // Check if local user exists
    if (!user_exists(local_username)) {
        syslog(LOG_AUTH|LOG_ERR, "%s: Local user %s does not exist", LOG_PREFIX, local_username);
        free(local_username);
        return PAM_USER_UNKNOWN;
    }

    // If username contains @, try Okta authentication
    if (strchr(username, '@')) {
        // Get Okta password
        const char *prompt = "Okta Password: ";
        char *resp = NULL;
        retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &resp, "%s", prompt);
        
        if (retval != PAM_SUCCESS || !resp) {
            syslog(LOG_AUTH|LOG_ERR, "%s: Failed to get Okta password", LOG_PREFIX);
            free(local_username);
            return PAM_AUTH_ERR;
        }

        okta_password = strdup(resp);
        free(resp);

        if (!okta_password) {
            syslog(LOG_AUTH|LOG_ERR, "%s: Memory allocation failed", LOG_PREFIX);
            free(local_username);
            return PAM_SYSTEM_ERR;
        }

        debug_log("%s: Attempting Okta authentication for %s", LOG_PREFIX, username);

        if (authenticate_with_okta(username, okta_password)) {
            syslog(LOG_AUTH|LOG_INFO, "%s: Okta authentication successful for %s", LOG_PREFIX, username);
            
            // Set local username for the session
            pam_set_item(pamh, PAM_USER, local_username);
            
            // Cleanup
            memset(okta_password, 0, strlen(okta_password));
            free(okta_password);
            free(local_username);
            
            return PAM_SUCCESS;
        }

        // Cleanup
        memset(okta_password, 0, strlen(okta_password));
        free(okta_password);
        syslog(LOG_AUTH|LOG_INFO, "%s: Okta authentication failed, falling back to local authentication", LOG_PREFIX);
    }

    free(local_username);
    return PAM_AUTH_ERR;
}

PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}
```

Update the Makefile to use json-glib:
```makefile
CC=gcc
CFLAGS=-fPIC -fno-stack-protector -Wall `pkg-config --cflags json-glib-1.0 glib-2.0`
LDFLAGS=-shared
LIBS=-lpam -lcurl `pkg-config --libs json-glib-1.0 glib-2.0`

TARGET=pam_okta.so
SOURCES=pam_okta.c

all: $(TARGET)

$(TARGET): $(SOURCES)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $(TARGET) $(SOURCES) $(LIBS)

install: $(TARGET)
	install -d /lib64/security
	install -m 755 $(TARGET) /lib64/security/
	install -m 600 okta_pam.conf /etc/okta_pam.conf

clean:
	rm -f $(TARGET)
```

Install dependencies:
For RHEL/CentOS:
```bash
sudo yum install gcc make pam-devel curl-devel json-glib-devel glib2-devel
```

For Ubuntu/Debian:
```bash
sudo apt-get install gcc make libpam0g-dev libcurl4-openssl-dev libjson-glib-dev libglib2.0-dev
```

The rest of the configuration (PAM config, SSHD config, etc.) remains the same as in the previous version.

Key changes in this version:
1. Replaced json-c with json-glib
2. Updated JSON handling to use GLib/json-glib APIs
3. Added proper memory management for GLib objects
4. More robust JSON parsing with error handling
5. Maintained the same functionality but with different JSON library

The authentication flow remains the same:
1. User connects with email address
2. PAM module prompts for Okta password
3. If Okta auth fails, falls back to local authentication
4. Uses local username throughout the session

The module still supports:
- Different passwords for Okta and Linux
- Automatic username mapping
- Detailed logging
- Configuration file support
- Secure password handling​​​​​​​​​​​​​​​​
