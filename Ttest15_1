Here's the complete code without any dependencies on json-c. I'll break it into two parts to ensure nothing is truncated.

Part 1 of 2:

```c
/*
 * PAM Okta Authentication Module
 * Supports password and MFA authentication
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <security/pam_modules.h>
#include <security/pam_ext.h>
#include <security/pam_appl.h>
#include <syslog.h>
#include <curl/curl.h>
#include <time.h>
#include <errno.h>
#include <unistd.h>
#include <stdarg.h>

#define CONFIG_FILE "/etc/exceed/okta-config.txt"
#define DEBUG_LOG "/var/log/okta_pam_debug.log"
#define MAX_LINE 1024
#define MAX_RESPONSE 4096
#define MAX_FACTORS 10
#define PUSH_POLL_INTERVAL_MS 500
#define PUSH_TIMEOUT_SEC 30

// Structure for CURL responses
struct MemoryStruct {
    char* memory;
    size_t size;
};

// Structure for MFA factors
struct MFAFactor {
    char id[MAX_LINE];
    char type[MAX_LINE];
    char provider[MAX_LINE];
    char status[MAX_LINE];
};

struct MFAFactors {
    struct MFAFactor factors[MAX_FACTORS];
    int count;
};

// Structure for Okta configuration
struct OktaConfig {
    char issuer[MAX_LINE];
    char client_id[MAX_LINE];
    char client_secret[MAX_LINE];
    char auth_endpoint[MAX_LINE];
};

// Debug logging function
static void debug_log(const char* format, ...) {
    FILE* fp = fopen(DEBUG_LOG, "a");
    if (!fp) return;

    time_t now = time(NULL);
    char timestamp[64];
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
    fprintf(fp, "[%s] ", timestamp);
    
    va_list args;
    va_start(args, format);
    vfprintf(fp, format, args);
    va_end(args);
    
    fprintf(fp, "\n");
    fclose(fp);
}

// CURL write callback
static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {
    size_t realsize = size * nmemb;
    struct MemoryStruct* mem = (struct MemoryStruct*)userp;

    char* ptr = realloc(mem->memory, mem->size + realsize + 1);
    if (!ptr) {
        debug_log("Failed to allocate memory for CURL response");
        return 0;
    }

    mem->memory = ptr;
    memcpy(&(mem->memory[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;
    
    return realsize;
}

// Function to get JSON value
static char* get_json_value(const char* json, const char* key) {
    static char value[MAX_LINE];
    char search_key[MAX_LINE];
    snprintf(search_key, sizeof(search_key), "\"%s\":\"", key);
    
    char* start = strstr(json, search_key);
    if (!start) {
        // Try without quotes around value
        snprintf(search_key, sizeof(search_key), "\"%s\":", key);
        start = strstr(json, search_key);
        if (!start) return NULL;
        start += strlen(search_key);
        
        // Skip whitespace
        while (*start == ' ' || *start == '\t' || *start == '\n') start++;
        
        if (*start == '"') {
            // If it starts with a quote, find ending quote
            start++;
            char* end = strchr(start, '"');
            if (!end) return NULL;
            size_t length = end - start;
            if (length >= MAX_LINE) length = MAX_LINE - 1;
            strncpy(value, start, length);
            value[length] = '\0';
        } else {
            // If no quote, read until comma, brace, or whitespace
            char* end = start;
            while (*end && *end != ',' && *end != '}' && *end != ' ' && *end != '\t' && *end != '\n') end++;
            size_t length = end - start;
            if (length >= MAX_LINE) length = MAX_LINE - 1;
            strncpy(value, start, length);
            value[length] = '\0';
        }
    } else {
        start += strlen(search_key);
        char* end = strchr(start, '"');
        if (!end) return NULL;
        size_t length = end - start;
        if (length >= MAX_LINE) length = MAX_LINE - 1;
        strncpy(value, start, length);
        value[length] = '\0';
    }
    
    return value;
}

// Function to prompt user
static int prompt_user(pam_handle_t* pamh, int msg_style, const char* prompt, char** response) {
    const struct pam_conv* conv;
    int ret = pam_get_item(pamh, PAM_CONV, (const void**)&conv);
    if (ret != PAM_SUCCESS) {
        debug_log("Failed to get PAM conversation");
        return ret;
    }

    struct pam_message msg;
    const struct pam_message* msgp;
    struct pam_response* resp;

    msg.msg_style = msg_style;
    msg.msg = prompt;
    msgp = &msg;
    
    debug_log("Displaying prompt: %s", prompt);
    ret = conv->conv(1, &msgp, &resp, conv->appdata_ptr);
    if (ret != PAM_SUCCESS) {
        debug_log("Conversation failed: %d", ret);
        return ret;
    }

    if (resp == NULL || resp[0].resp == NULL) {
        debug_log("No response received");
        free(resp);
        return PAM_CONV_ERR;
    }

    *response = strdup(resp[0].resp);
    debug_log("Received response (length: %zu)", strlen(resp[0].resp));
    
    memset(resp[0].resp, 0, strlen(resp[0].resp));
    free(resp[0].resp);
    free(resp);

    return PAM_SUCCESS;
}
```

Part 2 coming in the next message...​​​​​​​​​​​​​​​​
