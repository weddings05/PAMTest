Here's the complete, updated PAM module code with enhanced logging and Okta API status tracking:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <security/pam_modules.h>
#include <security/pam_ext.h>
#include <curl/curl.h>
#include <syslog.h>
#include <unistd.h>
#include <pwd.h>
#include <errno.h>
#include <time.h>
#include <ctype.h>

#define OKTA_API_URL "https://your-domain.okta.com/api/v1/authn"
#define MAX_USERNAME_LENGTH 256
#define MAX_PASSWORD_LENGTH 256
#define CONFIG_FILE "/etc/okta_pam.conf"
#define LOG_PREFIX "PAM_OKTA"
#define DEBUG_FILE "/var/log/okta_pam_debug.log"
#define MAX_RESPONSE_SIZE 4096

// Structure to store CURL response
struct curl_response {
    char *data;
    size_t size;
};

// Structure to store configuration
struct okta_config {
    char api_url[256];
    int debug;
};

// Global configuration
static struct okta_config config = {
    .api_url = OKTA_API_URL,
    .debug = 1
};

// Debug logging functions
static void file_debug_log(const char *format, ...) {
    FILE *f = fopen(DEBUG_FILE, "a");
    if (f) {
        va_list args;
        time_t now = time(NULL);
        char timestamp[64];
        strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
        
        fprintf(f, "[%s] ", timestamp);
        va_start(args, format);
        vfprintf(f, format, args);
        va_end(args);
        fprintf(f, "\n");
        fclose(f);
    }
}

static void debug_log(const char *format, ...) {
    va_list args;
    va_start(args, format);
    vsyslog(LOG_AUTH|LOG_DEBUG, format, args);
    va_end(args);
    
    // Also log to file
    va_start(args, format);
    file_debug_log(format, args);
    va_end(args);
}

// Extract value from JSON response
static char* extract_json_value(const char* json, const char* key) {
    static char value[256];
    char search_key[256];
    const char *start, *end;
    
    snprintf(search_key, sizeof(search_key), "\"%s\":\"", key);
    start = strstr(json, search_key);
    
    if (start) {
        start += strlen(search_key);
        end = strchr(start, '"');
        if (end) {
            size_t len = end - start;
            if (len < sizeof(value)) {
                strncpy(value, start, len);
                value[len] = '\0';
                return value;
            }
        }
    }
    return NULL;
}

// Load configuration from file
static void load_config(void) {
    FILE *fp = fopen(CONFIG_FILE, "r");
    if (!fp) {
        file_debug_log("%s: Could not open config file %s: %s", 
                      LOG_PREFIX, CONFIG_FILE, strerror(errno));
        return;
    }

    char line[512];
    while (fgets(line, sizeof(line), fp)) {
        char *key = strtok(line, "=");
        char *value = strtok(NULL, "\n");
        
        if (key && value) {
            while (*key && isspace(*key)) key++;
            while (*value && isspace(*value)) value++;
            
            if (strcmp(key, "api_url") == 0) {
                strncpy(config.api_url, value, sizeof(config.api_url) - 1);
            } else if (strcmp(key, "debug") == 0) {
                config.debug = atoi(value);
            }
        }
    }
    fclose(fp);
}

// CURL write callback
static size_t write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    struct curl_response *resp = (struct curl_response *)userp;

    if (resp->size + realsize >= MAX_RESPONSE_SIZE) {
        file_debug_log("%s: Response too large", LOG_PREFIX);
        return 0;
    }

    char *ptr = realloc(resp->data, resp->size + realsize + 1);
    if (!ptr) {
        file_debug_log("%s: Memory allocation failed", LOG_PREFIX);
        return 0;
    }

    resp->data = ptr;
    memcpy(&(resp->data[resp->size]), contents, realsize);
    resp->size += realsize;
    resp->data[resp->size] = 0;

    return realsize;
}

// Extract local username from email
static char* extract_local_username(const char* email) {
    if (!email) return NULL;
    
    char* local_username = strdup(email);
    if (!local_username) {
        file_debug_log("%s: Memory allocation failed for username extraction", LOG_PREFIX);
        return NULL;
    }

    char* at_sign = strchr(local_username, '@');
    if (at_sign) {
        *at_sign = '\0';
    }
    
    file_debug_log("%s: Extracted local username '%s' from '%s'", 
                   LOG_PREFIX, local_username, email);
    return local_username;
}

// Check if local user exists
static int user_exists(const char* username) {
    if (!username) return 0;

    struct passwd *pw = getpwnam(username);
    int exists = (pw != NULL);
    
    file_debug_log("%s: Checking if user '%s' exists: %s", 
                   LOG_PREFIX, username, exists ? "yes" : "no");
    
    return exists;
}

// Authenticate with Okta
static int authenticate_with_okta(const char* username, const char* password) {
    if (!username || !password) return 0;

    CURL *curl;
    CURLcode res;
    struct curl_response resp = {0};
    int auth_success = 0;
    long http_code = 0;

    file_debug_log("%s: Attempting Okta authentication for user '%s'", LOG_PREFIX, username);

    // Create JSON payload
    char *payload;
    size_t payload_size = strlen(username) + strlen(password) + 100;
    payload = malloc(payload_size);
    if (!payload) {
        file_debug_log("%s: Memory allocation failed for payload", LOG_PREFIX);
        return 0;
    }

    snprintf(payload, payload_size, 
             "{\"username\":\"%s\",\"password\":\"%s\"}", 
             username, password);

    curl = curl_easy_init();
    if (curl) {
        struct curl_slist *headers = NULL;
        headers = curl_slist_append(headers, "Accept: application/json");
        headers = curl_slist_append(headers, "Content-Type: application/json");

        curl_easy_setopt(curl, CURLOPT_URL, config.api_url);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload);
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&resp);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);

        res = curl_easy_perform(curl);
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        if (res == CURLE_OK && http_code == 200 && resp.data) {
            // Log full response for debugging
            file_debug_log("%s: Okta API Response: %s", LOG_PREFIX, resp.data);
            
            // Extract status and other relevant fields
            char *status = extract_json_value(resp.data, "status");
            char *error = extract_json_value(resp.data, "errorCode");
            
            if (status) {
                file_debug_log("%s: Okta authentication status: %s", LOG_PREFIX, status);
                auth_success = (strcmp(status, "SUCCESS") == 0);
            }
            
            if (error) {
                file_debug_log("%s: Okta error code: %s", LOG_PREFIX, error);
            }
        } else {
            file_debug_log("%s: Okta API call failed: %s (HTTP %ld)", 
                          LOG_PREFIX, curl_easy_strerror(res), http_code);
        }

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);
    }

    // Cleanup
    if (payload) {
        memset(payload, 0, strlen(payload));
        free(payload);
    }
    if (resp.data) {
        free(resp.data);
    }

    return auth_success;
}

PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    const char *username = NULL;
    char *okta_password = NULL;
    int retval;
    char *local_username = NULL;

    // Load configuration and initialize logging
    load_config();
    openlog("pam_okta", LOG_PID, LOG_AUTH);

    // Get username
    retval = pam_get_user(pamh, &username, NULL);
    if (retval != PAM_SUCCESS) {
        file_debug_log("%s: Failed to get username", LOG_PREFIX);
        return retval;
    }

    file_debug_log("%s: Processing authentication for user: %s", LOG_PREFIX, username);

    // Extract local username if it's an email
    local_username = extract_local_username(username);
    if (!local_username) {
        return PAM_SYSTEM_ERR;
    }

    // Check if local user exists
    if (!user_exists(local_username)) {
        file_debug_log("%s: Local user %s does not exist", LOG_PREFIX, local_username);
        free(local_username);
        return PAM_USER_UNKNOWN;
    }

    // Set the local username for subsequent modules
    retval = pam_set_item(pamh, PAM_USER, local_username);
    if (retval != PAM_SUCCESS) {
        file_debug_log("%s: Failed to set PAM_USER to %s", LOG_PREFIX, local_username);
        free(local_username);
        return retval;
    }

    // If username contains @, try Okta authentication
    if (strchr(username, '@')) {
        file_debug_log("%s: Email format detected, trying Okta auth first", LOG_PREFIX);

        // Get Okta password
        const char *prompt = "Okta Password: ";
        char *resp = NULL;
        retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &resp, "%s", prompt);
        
        if (retval != PAM_SUCCESS || !resp) {
            file_debug_log("%s: Failed to get Okta password", LOG_PREFIX);
            free(local_username);
            return PAM_AUTH_ERR;
        }

        okta_password = strdup(resp);
        free(resp);

        if (!okta_password) {
            file_debug_log("%s: Memory allocation failed for password", LOG_PREFIX);
            free(local_username);
            return PAM_SYSTEM_ERR;
        }

        // Try Okta authentication
        if (authenticate_with_okta(username, okta_password)) {
            file_debug_log("%s: Okta authentication successful for %s (local: %s)", 
                          LOG_PREFIX, username, local_username);
            
            // Cleanup
            memset(okta_password, 0, strlen(okta_password));
            free(okta_password);
            free(local_username);
            
            return PAM_SUCCESS;
        }

        file_debug_log("%s: Okta authentication failed, falling back to local auth for: %s", 
                      LOG_PREFIX, local_username);

        // Cleanup
        memset(okta_password, 0, strlen(okta_password));
        free(okta_password);
    }

    free(local_username);
    return PAM_AUTH_ERR;
}

PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}
```

And here's the Makefile:

```makefile
CC=gcc
CFLAGS=-fPIC -fno-stack-protector -Wall
LDFLAGS=-shared
LIBS=-lpam -lcurl

TARGET=pam_okta.so
SOURCES=pam_okta.c

all: $(TARGET)

$(TARGET): $(SOURCES)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $(TARGET) $(SOURCES) $(LIBS)

install: $(TARGET)
	install -d /lib64/security
	install -m 755 $(TARGET) /lib64/security/
	install -m 600 okta_pam.conf /etc/okta_pam.conf
	touch /var/log/okta_pam_debug.log
	chmod 640 /var/log/okta_pam_debug.log
	chown root:root /var/log/okta_pam_debug.log

clean:
	rm -f $(TARGET)
```

Key improvements in this version:
1. Enhanced logging of Okta API responses
2. Better error handling and status tracking
3. More detailed debug information
4. JSON response parsing for status and error codes
5. Proper cleanup of sensitive data
6. Maximum response size limit
7. Improved memory management
8. Better file descriptor handling
9. Clear separation of local and Okta authentication flows

To use:

1. Create config file:
```bash
sudo vi /etc/okta_pam.conf
```
```ini
api_url=https://your-domain.okta.com/api/v1/authn
debug=1
```

2. Build and install:
```bash
sudo make clean
sudo make
sudo make install
```

3. Verify logs:
```bash
sudo tail -f /var/log/okta_pam_debug.log
```

4. Test:
```bash
ssh test@example.com@hostname
```

The logs will now show:
- Full Okta API responses
- Authentication status details
- Error codes if any
- Username mapping process
- Local user verification
- Authentication flow steps

This should help with debugging any authentication issues!​​​​​​​​​​​​​​​​
