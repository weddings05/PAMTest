// Helper function to determine if it's an email login attempt
static int is_email_login(const char* input) {
    if (!input) return 0;
    
    // Count number of @ symbols
    int count = 0;
    const char* ptr = input;
    while ((ptr = strchr(ptr, '@')) != NULL) {
        count++;
        ptr++;
    }
    
    file_debug_log("%s: Checking if '%s' is email login (@ count: %d)", 
                   LOG_PREFIX, input, count);
    
    // If there is at least one @ symbol, consider it an email login
    return (count >= 1);
}

// Helper function to extract email when using SSH
static char* extract_email_from_ssh(const char* input) {
    if (!input) return NULL;

    char* copy = strdup(input);
    if (!copy) {
        file_debug_log("%s: Memory allocation failed in extract_email_from_ssh", LOG_PREFIX);
        return NULL;
    }

    // Find the last @ symbol (which would be the hostname separator)
    char* last_at = strrchr(copy, '@');
    if (last_at) {
        *last_at = '\0';  // Terminate string at the last @
        char* email = strdup(copy);
        free(copy);
        file_debug_log("%s: Extracted email: %s from input: %s", 
                      LOG_PREFIX, email ? email : "NULL", input);
        return email;
    }

    free(copy);
    return NULL;
}

// Extract local username from email
static char* extract_local_username(const char* email) {
    if (!email) return NULL;
    
    char* local_username = strdup(email);
    if (!local_username) {
        file_debug_log("%s: Memory allocation failed for username extraction", LOG_PREFIX);
        return NULL;
    }

    char* at_sign = strchr(local_username, '@');
    if (at_sign) {
        *at_sign = '\0';
    }
    
    file_debug_log("%s: Extracted local username '%s' from '%s'", 
                   LOG_PREFIX, local_username, email);
    return local_username;
}

// Check if local user exists
static int user_exists(const char* username) {
    if (!username) return 0;

    struct passwd *pw = getpwnam(username);
    int exists = (pw != NULL);
    
    file_debug_log("%s: Checking if user '%s' exists: %s", 
                   LOG_PREFIX, username, exists ? "yes" : "no");
    
    return exists;
}

// Authenticate with Okta
static int authenticate_with_okta(const char* username, const char* password) {
    if (!username || !password) {
        file_debug_log("%s: Username or password is NULL", LOG_PREFIX);
        return 0;
    }

    CURL *curl;
    CURLcode res;
    struct curl_response resp = {0};
    int auth_success = 0;
    long http_code = 0;

    file_debug_log("%s: Starting Okta authentication for user: %s", LOG_PREFIX, username);

    // Create JSON payload
    char *payload;
    size_t payload_size = strlen(username) + strlen(password) + 100;
    payload = malloc(payload_size);
    if (!payload) {
        file_debug_log("%s: Memory allocation failed for payload", LOG_PREFIX);
        return 0;
    }

    snprintf(payload, payload_size, 
             "{\"username\":\"%s\",\"password\":\"%s\"}", 
             username, password);

    file_debug_log("%s: Initializing CURL with payload: %s", LOG_PREFIX, payload);
    curl = curl_easy_init();
    if (curl) {
        struct curl_slist *headers = NULL;
        headers = curl_slist_append(headers, "Accept: application/json");
        headers = curl_slist_append(headers, "Content-Type: application/json");

        file_debug_log("%s: Setting CURL options with URL: %s", LOG_PREFIX, config.api_url);
        
        curl_easy_setopt(curl, CURLOPT_URL, config.api_url);
        curl_easy_setopt(curl, CURLOPT_POST, 1L);  // Explicitly set POST method
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, strlen(payload));
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&resp);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);
        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

        file_debug_log("%s: Performing CURL request", LOG_PREFIX);
        res = curl_easy_perform(curl);
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        file_debug_log("%s: CURL request completed. Response code: %ld", LOG_PREFIX, http_code);

        if (res == CURLE_OK) {
            file_debug_log("%s: CURL request successful", LOG_PREFIX);
            if (resp.data) {
                file_debug_log("%s: Received response data: %s", LOG_PREFIX, resp.data);
            }
            
            if (http_code == 200 && resp.data && strstr(resp.data, "\"status\":\"SUCCESS\"")) {
                auth_success = 1;
                file_debug_log("%s: Authentication successful", LOG_PREFIX);
            } else {
                file_debug_log("%s: Authentication failed - HTTP code: %ld", LOG_PREFIX, http_code);
                if (resp.data) {
                    file_debug_log("%s: Error response: %s", LOG_PREFIX, resp.data);
                }
            }
        } else {
            file_debug_log("%s: CURL request failed: %s", LOG_PREFIX, curl_easy_strerror(res));
        }

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);
    }

    // Cleanup
    if (payload) {
        memset(payload, 0, strlen(payload));
        free(payload);
    }
    if (resp.data) {
        free(resp.data);
    }

    return auth_success;
}
