// Handle factor selection
static int select_mfa_factor(pam_handle_t* pamh, struct MFAFactors* factors) {
    char prompt[MAX_LINE * 3];
    char* response = NULL;
    
    snprintf(prompt, sizeof(prompt), "Select MFA method:\n");
    for (int i = 0; i < factors->count; i++) {
        char factor_desc[MAX_LINE];
        snprintf(factor_desc, sizeof(factor_desc), 
                "%d) %s via %s\n", 
                i + 1, factors->factors[i].type, factors->factors[i].provider);
        strncat(prompt, factor_desc, sizeof(prompt) - strlen(prompt) - 1);
    }
    
    int ret = prompt_user(pamh, PAM_PROMPT_ECHO_ON, prompt, &response);
    if (ret != PAM_SUCCESS || !response) {
        debug_log("Failed to get factor selection");
        return -1;
    }
    
    int selection = atoi(response) - 1;
    free(response);
    
    if (selection < 0 || selection >= factors->count) {
        debug_log("Invalid factor selection: %d", selection);
        return -1;
    }
    
    debug_log("Selected factor %d", selection + 1);
    return selection;
}

// Handle push verification
static int handle_push_verification(CURL* curl, const char* state_token, 
                                  const char* factor_id, struct MemoryStruct* chunk,
                                  const char* verify_endpoint) {
    CURLcode res;
    char post_data[MAX_LINE * 2];
    int max_attempts = PUSH_TIMEOUT_SEC * (1000 / PUSH_POLL_INTERVAL_MS);
    
    debug_log("Starting push verification");
    
    // Send push notification
    snprintf(post_data, sizeof(post_data),
             "{\"stateToken\":\"%s\"}", state_token);
             
    curl_easy_setopt(curl, CURLOPT_URL, verify_endpoint);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);
    
    res = curl_easy_perform(curl);
    if (res != CURLE_OK) {
        debug_log("Failed to send push notification: %s", curl_easy_strerror(res));
        return PAM_AUTH_ERR;
    }
    
    debug_log("Push notification sent, polling for response");
    
    // Poll for response
    for (int i = 0; i < max_attempts; i++) {
        chunk->size = 0;
        res = curl_easy_perform(curl);
        
        if (res != CURLE_OK) {
            debug_log("Push verification check failed: %s", curl_easy_strerror(res));
            return PAM_AUTH_ERR;
        }
        
        char* status = get_json_string(chunk->memory, "status");
        if (status) {
            debug_log("Push status: %s", status);
            if (strcmp(status, "SUCCESS") == 0) {
                return PAM_SUCCESS;
            } else if (strcmp(status, "REJECTED") == 0) {
                debug_log("Push notification rejected");
                return PAM_AUTH_ERR;
            }
        }
        
        usleep(PUSH_POLL_INTERVAL_MS * 1000);
        debug_log("Polling attempt %d of %d", i + 1, max_attempts);
    }
    
    debug_log("Push verification timed out");
    return PAM_AUTH_ERR;
}

// Handle code-based verification (TOTP, SMS, Email)
static int handle_code_verification(pam_handle_t* pamh, CURL* curl,
                                  const char* state_token, const char* factor_id,
                                  struct MemoryStruct* chunk, const char* verify_endpoint) {
    CURLcode res;
    char* mfa_code = NULL;
    char post_data[MAX_LINE * 2];
    
    debug_log("Starting code verification");
    
    int ret = prompt_user(pamh, PAM_PROMPT_ECHO_ON,
                         "Enter your verification code: ", &mfa_code);
    if (ret != PAM_SUCCESS || !mfa_code) {
        debug_log("Failed to get verification code");
        return PAM_AUTH_ERR;
    }
    
    snprintf(post_data, sizeof(post_data),
             "{\"stateToken\":\"%s\",\"passCode\":\"%s\"}",
             state_token, mfa_code);
             
    debug_log("Verifying code");
    
    memset(mfa_code, 0, strlen(mfa_code));
    free(mfa_code);
    
    curl_easy_setopt(curl, CURLOPT_URL, verify_endpoint);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);
    
    chunk->size = 0;
    res = curl_easy_perform(curl);
    
    if (res != CURLE_OK) {
        debug_log("Code verification failed: %s", curl_easy_strerror(res));
        return PAM_AUTH_ERR;
    }
    
    char* status = get_json_string(chunk->memory, "status");
    debug_log("Verification status: %s", status ? status : "null");
    
    return (status && strcmp(status, "SUCCESS") == 0) ? PAM_SUCCESS : PAM_AUTH_ERR;
}

// Handle WebAuthn/FIDO2 verification
static int handle_webauthn_verification(pam_handle_t* pamh, CURL* curl,
                                      const char* state_token, const char* factor_id,
                                      struct MemoryStruct* chunk, const char* verify_endpoint) {
    debug_log("WebAuthn/FIDO2 authentication not yet supported");
    return PAM_AUTH_ERR;
}

// Main authentication function
static int authenticate_with_okta(pam_handle_t* pamh, const char* username, 
                                const char* password, struct OktaConfig* config) {
    debug_log("Starting Okta authentication for user: %s", username);
    
    CURL* curl;
    CURLcode res;
    struct MemoryStruct chunk;
    int ret = PAM_AUTH_ERR;

    chunk.memory = malloc(1);
    chunk.size = 0;

    curl = curl_easy_init();
    if (!curl) {
        debug_log("Failed to initialize CURL");
        free(chunk.memory);
        return PAM_SYSTEM_ERR;
    }

    // Initial authentication request
    char post_data[MAX_LINE * 3];
    snprintf(post_data, sizeof(post_data),
             "{\"username\":\"%s\",\"password\":\"%s\"}", username, password);

    struct curl_slist* headers = NULL;
    headers = curl_slist_append(headers, "Accept: application/json");
    headers = curl_slist_append(headers, "Content-Type: application/json");

    // SSL and curl options
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

    // Ensure URL is properly formatted
    char formatted_url[MAX_LINE * 2];
    if (strncmp(config->auth_endpoint, "https://", 8) != 0) {
        snprintf(formatted_url, sizeof(formatted_url), 
                "https://%s", config->auth_endpoint);
    } else {
        strncpy(formatted_url, config->auth_endpoint, sizeof(formatted_url) - 1);
    }
    formatted_url[sizeof(formatted_url) - 1] = '\0';

    curl_easy_setopt(curl, CURLOPT_URL, formatted_url);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);

    char curl_error[CURL_ERROR_SIZE];
    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curl_error);

    debug_log("Sending authentication request to URL: %s", formatted_url);
    
    res = curl_easy_perform(curl);

    if (res != CURLE_OK) {
        debug_log("CURL request failed: %s", curl_easy_strerror(res));
        debug_log("Detailed error: %s", curl_error);
        ret = PAM_AUTH_ERR;
        goto cleanup;
    }

    debug_log("Received response: %s", chunk.memory);

    char* status = get_json_string(chunk.memory, "status");
    if (!status) {
        debug_log("No status in response");
        ret = PAM_AUTH_ERR;
        goto cleanup;
    }

    debug_log("Authentication status: %s", status);

    if (strcmp(status, "SUCCESS") == 0) {
        debug_log("Authentication successful without MFA");
        ret = PAM_SUCCESS;
    } else if (strcmp(status, "MFA_REQUIRED") == 0) {
        debug_log("MFA required, processing MFA challenge");
        
        char* state_token = get_json_string(chunk.memory, "stateToken");
        if (!state_token) {
            debug_log("No state token found");
            ret = PAM_AUTH_ERR;
            goto cleanup;
        }
