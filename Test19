static int parse_mfa_factors(const char* json_str, struct MFAFactors* factors) {
    debug_log("Starting to parse MFA factors");
    factors->count = 0;

    // First find _embedded
    char* embedded = strstr(json_str, "\"_embedded\":");
    if (!embedded) {
        debug_log("No _embedded section found");
        return -1;
    }
    debug_log("Found _embedded section");

    // Find factors array within _embedded
    char* factors_arr = strstr(embedded, "\"factors\":[");
    if (!factors_arr) {
        debug_log("No factors array found");
        return -1;
    }
    debug_log("Found factors array");

    // Move to start of array content
    factors_arr += strlen("\"factors\":[");

    // Process each factor object
    char* current = factors_arr;
    while (*current != '\0' && *current != ']' && factors->count < MAX_FACTORS) {
        // Find start of factor object
        while (*current != '{' && *current != ']' && *current != '\0') {
            current++;
        }

        if (*current != '{') break;

        // Extract complete factor object
        char factor_buffer[MAX_LINE * 4] = {0};
        int brace_count = 1;
        size_t pos = 0;
        current++; // Skip opening brace
        
        // Copy the entire object
        while (*current && brace_count > 0 && pos < sizeof(factor_buffer) - 1) {
            if (*current == '{') brace_count++;
            if (*current == '}') brace_count--;
            factor_buffer[pos++] = *current++;
        }
        factor_buffer[pos] = '\0';

        debug_log("Extracted factor object: %s", factor_buffer);

        // Reset all values
        memset(factors->factors[factors->count].id, 0, MAX_LINE);
        memset(factors->factors[factors->count].type, 0, MAX_LINE);
        memset(factors->factors[factors->count].provider, 0, MAX_LINE);

        // Find and extract id
        char* id_start = strstr(factor_buffer, "\"id\":\"");
        if (id_start) {
            id_start += strlen("\"id\":\"");
            char* id_end = strchr(id_start, '"');
            if (id_end) {
                size_t len = id_end - id_start;
                strncpy(factors->factors[factors->count].id, id_start, len);
                factors->factors[factors->count].id[len] = '\0';
                debug_log("Found ID: %s", factors->factors[factors->count].id);
            }
        }

        // Find and extract factorType
        char* type_start = strstr(factor_buffer, "\"factorType\":\"");
        if (type_start) {
            type_start += strlen("\"factorType\":\"");
            char* type_end = strchr(type_start, '"');
            if (type_end) {
                size_t len = type_end - type_start;
                strncpy(factors->factors[factors->count].type, type_start, len);
                factors->factors[factors->count].type[len] = '\0';
                debug_log("Found Type: %s", factors->factors[factors->count].type);
            }
        }

        // Find and extract provider
        char* provider_start = strstr(factor_buffer, "\"provider\":\"");
        if (provider_start) {
            provider_start += strlen("\"provider\":\"");
            char* provider_end = strchr(provider_start, '"');
            if (provider_end) {
                size_t len = provider_end - provider_start;
                strncpy(factors->factors[factors->count].provider, provider_start, len);
                factors->factors[factors->count].provider[len] = '\0';
                debug_log("Found Provider: %s", factors->factors[factors->count].provider);
            }
        }

        // Verify all fields were found
        if (factors->factors[factors->count].id[0] && 
            factors->factors[factors->count].type[0] && 
            factors->factors[factors->count].provider[0]) {
            
            debug_log("Successfully parsed factor %d:", factors->count + 1);
            debug_log("  ID: %s", factors->factors[factors->count].id);
            debug_log("  Type: %s", factors->factors[factors->count].type);
            debug_log("  Provider: %s", factors->factors[factors->count].provider);
            
            factors->count++;
        } else {
            debug_log("Missing fields in factor - ID:%s Type:%s Provider:%s",
                     factors->factors[factors->count].id[0] ? "yes" : "no",
                     factors->factors[factors->count].type[0] ? "yes" : "no",
                     factors->factors[factors->count].provider[0] ? "yes" : "no");
        }
    }

    debug_log("Total factors found: %d", factors->count);
    return factors->count > 0 ? 0 : -1;
}
