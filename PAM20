// Function to prompt for both username and password at once
static int prompt_credentials(pam_handle_t* pamh, char** username, char** password) {
    const struct pam_conv* conv;
    int ret = pam_get_item(pamh, PAM_CONV, (const void**)&conv);
    if (ret != PAM_SUCCESS) {
        debug_log("Failed to get PAM conversation");
        return ret;
    }

    if (conv == NULL || conv->conv == NULL) {
        debug_log("PAM conversation is null");
        return PAM_SYSTEM_ERR;
    }

    // Set up messages for both username and password
    struct pam_message msgs[2];
    const struct pam_message* msg_ptrs[2];
    struct pam_response* resp = NULL;

    msgs[0].msg_style = PAM_PROMPT_ECHO_ON;
    msgs[0].msg = "Okta username: ";
    msgs[1].msg_style = PAM_PROMPT_ECHO_OFF;
    msgs[1].msg = "Okta password: ";

    msg_ptrs[0] = &msgs[0];
    msg_ptrs[1] = &msgs[1];

    debug_log("Displaying username and password prompts");
    ret = conv->conv(2, msg_ptrs, &resp, conv->appdata_ptr);
    if (ret != PAM_SUCCESS) {
        debug_log("Conversation failed: %d", ret);
        return ret;
    }

    if (resp == NULL) {
        debug_log("Response is null");
        return PAM_CONV_ERR;
    }

    // Check username response
    if (resp[0].resp == NULL) {
        debug_log("Username response is null");
        free(resp);
        return PAM_CONV_ERR;
    }

    // Check password response
    if (resp[1].resp == NULL) {
        debug_log("Password response is null");
        memset(resp[0].resp, 0, strlen(resp[0].resp));
        free(resp[0].resp);
        free(resp);
        return PAM_CONV_ERR;
    }

    // Copy responses
    *username = strdup(resp[0].resp);
    *password = strdup(resp[1].resp);

    debug_log("Got credentials - username length: %zu", strlen(*username));

    // Clean up responses
    memset(resp[0].resp, 0, strlen(resp[0].resp));
    memset(resp[1].resp, 0, strlen(resp[1].resp));
    free(resp[0].resp);
    free(resp[1].resp);
    free(resp);

    return PAM_SUCCESS;
}

// Updated PAM authentication function
PAM_EXTERN int pam_sm_authenticate(pam_handle_t* pamh, int flags, int argc, const char** argv) {
    debug_log("Starting PAM Okta authentication module");
    
    char* okta_username = NULL;
    char* okta_password = NULL;
    int ret;
    struct OktaConfig config;

    // Initialize CURL globally
    CURLcode curl_init = curl_global_init(CURL_GLOBAL_DEFAULT);
    if (curl_init != CURLE_OK) {
        debug_log("Failed to initialize CURL: %s", curl_easy_strerror(curl_init));
        return PAM_SYSTEM_ERR;
    }

    // Always prompt for both Okta username and password
    ret = prompt_credentials(pamh, &okta_username, &okta_password);
    if (ret != PAM_SUCCESS) {
        debug_log("Failed to get credentials: %d", ret);
        curl_global_cleanup();
        return PAM_AUTH_ERR;
    }

    // Read configuration
    if (read_config(&config) != 0) {
        debug_log("Failed to read Okta configuration");
        ret = PAM_AUTH_ERR;
        goto cleanup;
    }

    // Authenticate with Okta
    ret = authenticate_with_okta(pamh, okta_username, okta_password, &config);

cleanup:
    // Clean up
    if (okta_username) {
        memset(okta_username, 0, strlen(okta_username));
        free(okta_username);
    }
    if (okta_password) {
        memset(okta_password, 0, strlen(okta_password));
        free(okta_password);
    }

    curl_global_cleanup();

    if (ret != PAM_SUCCESS) {
        debug_log("Authentication failed, returning PAM_AUTH_ERR");
        return PAM_AUTH_ERR;
    }

    debug_log("Authentication completed successfully");
    return PAM_SUCCESS;
}
