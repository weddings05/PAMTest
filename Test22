static int prompt_mfa(pam_handle_t* pamh, const char* prompt, char** response) {
    const struct pam_conv* conv;
    struct pam_message msg;
    const struct pam_message* msg_ptr[1];
    struct pam_response* resp = NULL;

    // Get the conversation function
    int ret = pam_get_item(pamh, PAM_CONV, (const void**)&conv);
    if (ret != PAM_SUCCESS) {
        debug_log("Failed to get PAM conversation for MFA: %d", ret);
        return ret;
    }

    if (conv == NULL || conv->conv == NULL) {
        debug_log("PAM conversation is null for MFA prompt");
        return PAM_SYSTEM_ERR;
    }

    // Set up the message
    msg.msg_style = PAM_PROMPT_ECHO_ON;  // Show input for MFA selection
    msg.msg = prompt;
    msg_ptr[0] = &msg;

    debug_log("Displaying MFA prompt:\n%s", prompt);

    // Call conversation function
    ret = conv->conv(1, msg_ptr, &resp, conv->appdata_ptr);
    debug_log("MFA conversation returned: %d", ret);

    if (ret != PAM_SUCCESS) {
        debug_log("MFA conversation failed: %d", ret);
        return ret;
    }

    if (resp == NULL) {
        debug_log("MFA response struct is null");
        return PAM_CONV_ERR;
    }

    if (resp[0].resp == NULL) {
        debug_log("MFA response string is null");
        free(resp);
        return PAM_CONV_ERR;
    }

    // Copy the response
    *response = strdup(resp[0].resp);
    if (*response == NULL) {
        debug_log("Failed to allocate memory for MFA response");
        memset(resp[0].resp, 0, strlen(resp[0].resp));
        free(resp[0].resp);
        free(resp);
        return PAM_BUF_ERR;
    }

    debug_log("Got MFA response (length: %zu)", strlen(*response));

    // Clean up
    memset(resp[0].resp, 0, strlen(resp[0].resp));
    free(resp[0].resp);
    free(resp);

    return PAM_SUCCESS;
}
