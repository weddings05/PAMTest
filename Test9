#define PAM_SM_AUTH
#include <security/pam_modules.h>
#include <security/pam_ext.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>
#include <syslog.h>

#define PORT 8000
#define CONFIG_FILE "/etc/pam_okta.conf"
#define MAX_BUFFER 4096
#define DEBUG_FILE "/var/log/pam_okta.log"
#define RESPONSE "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n<html><body><script>window.close();</script>Authentication successful! You can close this window.</body></html>"

struct auth_context {
    char *auth_code;
    int server_fd;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int auth_completed;
};

struct config {
    char okta_domain[256];
    char client_id[256];
    char client_secret[256];
    char redirect_uri[256];
};

static struct config conf;

struct string {
    char *ptr;
    size_t len;
};

static void log_message(int priority, const char *format, ...) {
    va_list args;
    va_start(args, format);
    openlog("pam_okta", LOG_PID, LOG_AUTHPRIV);
    vsyslog(priority, format, args);
    closelog();
    va_end(args);

    FILE *f = fopen(DEBUG_FILE, "a");
    if (f) {
        time_t now = time(NULL);
        char timestamp[64];
        strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
        fprintf(f, "[%s] ", timestamp);
        va_start(args, format);
        vfprintf(f, format, args);
        fprintf(f, "\n");
        va_end(args);
        fclose(f);
    }
}

void init_string(struct string *s) {
    s->len = 0;
    s->ptr = malloc(s->len + 1);
    if (s->ptr == NULL) {
        log_message(LOG_ERR, "Failed to allocate memory");
        exit(1);
    }
    s->ptr[0] = '\0';
}

size_t writefunc(void *ptr, size_t size, size_t nmemb, struct string *s) {
    size_t new_len = s->len + size * nmemb;
    s->ptr = realloc(s->ptr, new_len + 1);
    if (s->ptr == NULL) {
        log_message(LOG_ERR, "Failed to reallocate memory");
        exit(1);
    }
    memcpy(s->ptr + s->len, ptr, size * nmemb);
    s->ptr[new_len] = '\0';
    s->len = new_len;
    return size * nmemb;
}

static char* extract_auth_code(const char* request) {
    const char* code_start = strstr(request, "code=");
    if (!code_start) {
        return NULL;
    }
    
    code_start += 5;  // Skip "code="
    const char* code_end = strchr(code_start, '&');
    if (!code_end) {
        code_end = strchr(code_start, ' ');
    }
    if (!code_end) {
        code_end = strchr(code_start, '\r');
    }
    if (!code_end) {
        code_end = strchr(code_start, '\n');
    }
    
    if (!code_end) {
        return NULL;
    }
    
    size_t code_length = code_end - code_start;
    char* auth_code = malloc(code_length + 1);
    strncpy(auth_code, code_start, code_length);
    auth_code[code_length] = '\0';
    
    return auth_code;
}

static void* handle_connection(void* arg) {
    struct auth_context *context = (struct auth_context *)arg;
    int server_fd = context->server_fd;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    char buffer[MAX_BUFFER] = {0};
    
    while (!context->auth_completed) {
        int new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);
        if (new_socket < 0) {
            continue;
        }
        
        ssize_t bytes_read = read(new_socket, buffer, MAX_BUFFER);
        if (bytes_read > 0) {
            char* auth_code = extract_auth_code(buffer);
            if (auth_code) {
                pthread_mutex_lock(&context->mutex);
                context->auth_code = auth_code;
                context->auth_completed = 1;
                pthread_cond_signal(&context->cond);
                pthread_mutex_unlock(&context->mutex);
                
                write(new_socket, RESPONSE, strlen(RESPONSE));
            }
        }
        close(new_socket);
    }
    return NULL;
}

static int load_config() {
    FILE *fp = fopen(CONFIG_FILE, "r");
    if (!fp) {
        log_message(LOG_ERR, "Failed to open config file: %s", CONFIG_FILE);
        return -1;
    }

    char line[256];
    while (fgets(line, sizeof(line), fp)) {
        char *key = strtok(line, "=");
        char *value = strtok(NULL, "\n");
        if (key && value) {
            while (*value == ' ') value++;
            char *end = value + strlen(value) - 1;
            while (end > value && (*end == ' ' || *end == '\n')) *end-- = '\0';
            
            if (strcmp(key, "okta_domain") == 0) {
                strncpy(conf.okta_domain, value, sizeof(conf.okta_domain) - 1);
            } else if (strcmp(key, "client_id") == 0) {
                strncpy(conf.client_id, value, sizeof(conf.client_id) - 1);
            } else if (strcmp(key, "client_secret") == 0) {
                strncpy(conf.client_secret, value, sizeof(conf.client_secret) - 1);
            } else if (strcmp(key, "redirect_uri") == 0) {
                strncpy(conf.redirect_uri, value, sizeof(conf.redirect_uri) - 1);
            }
        }
    }
    fclose(fp);
    return 0;
}

static int verify_okta_token(const char *auth_code, const char *username) {
    CURL *curl;
    CURLcode res;
    struct string s;
    init_string(&s);
    
    curl = curl_easy_init();
    if (!curl) {
        log_message(LOG_ERR, "Failed to initialize CURL");
        return PAM_AUTH_ERR;
    }

    char post_fields[MAX_BUFFER];
    snprintf(post_fields, sizeof(post_fields),
             "grant_type=authorization_code&code=%s&redirect_uri=%s&client_id=%s&client_secret=%s",
             auth_code, conf.redirect_uri, conf.client_id, conf.client_secret);

    char url[MAX_BUFFER];
    snprintf(url, sizeof(url), "https://%s/oauth2/v1/token", conf.okta_domain);

    log_message(LOG_INFO, "Requesting token from Okta");
    
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_fields);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writefunc);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &s);

    res = curl_easy_perform(curl);
    curl_easy_cleanup(curl);

    if (res != CURLE_OK) {
        log_message(LOG_ERR, "Token request failed: %s", curl_easy_strerror(res));
        free(s.ptr);
        return PAM_AUTH_ERR;
    }

    // Check if we received an access token
    if (strstr(s.ptr, "access_token") == NULL) {
        log_message(LOG_ERR, "No access token in response");
        free(s.ptr);
        return PAM_AUTH_ERR;
    }

    free(s.ptr);
    log_message(LOG_INFO, "Successfully validated token for user: %s", username);
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    const char *username;
    int ret;

    log_message(LOG_INFO, "Starting Okta authentication process");

    if (load_config() != 0) {
        log_message(LOG_ERR, "Failed to load configuration");
        return PAM_IGNORE;
    }

    ret = pam_get_user(pamh, &username, NULL);
    if (ret != PAM_SUCCESS) {
        log_message(LOG_ERR, "Failed to get username");
        return PAM_IGNORE;
    }

    // Create socket server
    struct auth_context context = {0};
    int server_fd;
    struct sockaddr_in address;
    
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        log_message(LOG_ERR, "Socket creation failed");
        return PAM_IGNORE;
    }
    
    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        log_message(LOG_ERR, "Setsockopt failed");
        close(server_fd);
        return PAM_IGNORE;
    }
    
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
    
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        log_message(LOG_ERR, "Bind failed");
        close(server_fd);
        return PAM_IGNORE;
    }
    
    if (listen(server_fd, 3) < 0) {
        log_message(LOG_ERR, "Listen failed");
        close(server_fd);
        return PAM_IGNORE;
    }

    context.server_fd = server_fd;
    pthread_mutex_init(&context.mutex, NULL);
    pthread_cond_init(&context.cond, NULL);

    // Start server thread
    pthread_t server_thread;
    if (pthread_create(&server_thread, NULL, handle_connection, &context) != 0) {
        log_message(LOG_ERR, "Failed to create server thread");
        close(server_fd);
        return PAM_IGNORE;
    }

    // Launch browser for authentication
    char auth_url[MAX_BUFFER];
    snprintf(auth_url, sizeof(auth_url),
             "xdg-open 'https://%s/oauth2/v1/authorize?client_id=%s&response_type=code"
             "&scope=openid%%20profile&redirect_uri=%s&state=state123&login_hint=%s'",
             conf.okta_domain, conf.client_id, conf.redirect_uri, username);

    log_message(LOG_INFO, "Launching browser for authentication");
    system(auth_url);

    // Wait for authentication completion
    pthread_mutex_lock(&context.mutex);
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    ts.tv_sec += 300; // 5-minute timeout
    
    while (!context.auth_completed) {
        if (pthread_cond_timedwait(&context.cond, &context.mutex, &ts) == ETIMEDOUT) {
            log_message(LOG_WARNING, "Authentication timed out");
            pthread_mutex_unlock(&context.mutex);
            close(server_fd);
            return PAM_IGNORE;
        }
    }
    pthread_mutex_unlock(&context.mutex);

    log_message(LOG_INFO, "Received authentication response");
    close(server_fd);
    pthread_join(server_thread, NULL);

    // Verify the token
    ret = verify_okta_token(context.auth_code, username);
    free(context.auth_code);

    pthread_mutex_destroy(&context.mutex);
    pthread_cond_destroy(&context.cond);

    if (ret != PAM_SUCCESS) {
        log_message(LOG_WARNING, "Okta authentication failed, allowing fallback");
        return PAM_IGNORE;
    }

    log_message(LOG_INFO, "Okta authentication successful");
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_setcred(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_close_session(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}

PAM_EXTERN int pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv) {
    return PAM_SUCCESS;
}
