Here's Part 2 of 2:

```c
// Read configuration
static int read_config(struct OktaConfig* config) {
    debug_log("Reading Okta configuration");
    
    FILE* fp = fopen(CONFIG_FILE, "r");
    if (!fp) {
        debug_log("Cannot open config file: %s", strerror(errno));
        return -1;
    }

    memset(config, 0, sizeof(struct OktaConfig));

    char line[MAX_LINE];
    while (fgets(line, sizeof(line), fp)) {
        if (line[0] == '#' || line[0] == '\n') continue;
        
        char* key = strtok(line, "=");
        char* value = strtok(NULL, "\n");
        
        if (key && value) {
            while (*value == ' ') value++;
            
            if (strcmp(key, "issuer") == 0)
                strncpy(config->issuer, value, MAX_LINE - 1);
            else if (strcmp(key, "client_id") == 0)
                strncpy(config->client_id, value, MAX_LINE - 1);
            else if (strcmp(key, "client_secret") == 0)
                strncpy(config->client_secret, value, MAX_LINE - 1);
            else if (strcmp(key, "auth_endpoint") == 0)
                strncpy(config->auth_endpoint, value, MAX_LINE - 1);
        }
    }
    fclose(fp);
    return 0;
}

// Parse MFA factors from response
static int parse_mfa_factors(const char* json_str, struct MFAFactors* factors) {
    factors->count = 0;
    char* current_pos = strstr(json_str, "\"_embedded\":{\"factors\":[");
    
    if (!current_pos) {
        debug_log("No factors found in response");
        return -1;
    }
    
    current_pos += strlen("\"_embedded\":{\"factors\":[");
    int brace_count = 1;
    char factor_buffer[MAX_LINE * 2];
    
    while (*current_pos && factors->count < MAX_FACTORS) {
        if (*current_pos == '{') {
            // Start of a factor object
            int buffer_pos = 0;
            brace_count = 1;
            
            // Copy entire factor object
            while (brace_count > 0 && *current_pos) {
                factor_buffer[buffer_pos++] = *current_pos;
                if (*current_pos == '{') brace_count++;
                if (*current_pos == '}') brace_count--;
                current_pos++;
            }
            factor_buffer[buffer_pos] = '\0';
            
            // Extract factor details
            char* id = get_json_value(factor_buffer, "id");
            char* type = get_json_value(factor_buffer, "factorType");
            char* provider = get_json_value(factor_buffer, "provider");
            char* status = get_json_value(factor_buffer, "status");
            
            if (id && type && provider && status) {
                strncpy(factors->factors[factors->count].id, id, MAX_LINE - 1);
                strncpy(factors->factors[factors->count].type, type, MAX_LINE - 1);
                strncpy(factors->factors[factors->count].provider, provider, MAX_LINE - 1);
                strncpy(factors->factors[factors->count].status, status, MAX_LINE - 1);
                factors->count++;
            }
        } else {
            current_pos++;
        }
    }
    
    return factors->count > 0 ? 0 : -1;
}

// Handle factor selection
static int select_mfa_factor(pam_handle_t* pamh, struct MFAFactors* factors) {
    char prompt[MAX_LINE * 3];
    char* response = NULL;
    
    snprintf(prompt, sizeof(prompt), "Select MFA method:\n");
    for (int i = 0; i < factors->count; i++) {
        char factor_desc[MAX_LINE];
        snprintf(factor_desc, sizeof(factor_desc), 
                "%d) %s via %s\n", 
                i + 1, factors->factors[i].type, factors->factors[i].provider);
        strncat(prompt, factor_desc, sizeof(prompt) - strlen(prompt) - 1);
    }
    
    int ret = prompt_user(pamh, PAM_PROMPT_ECHO_ON, prompt, &response);
    if (ret != PAM_SUCCESS || !response) {
        return -1;
    }
    
    int selection = atoi(response) - 1;
    free(response);
    
    if (selection < 0 || selection >= factors->count) {
        return -1;
    }
    
    return selection;
}

// Handle push verification
static int handle_push_verification(CURL* curl, const char* state_token, 
                                  const char* factor_id, struct MemoryStruct* chunk,
                                  const char* verify_endpoint) {
    CURLcode res;
    char post_data[MAX_LINE * 2];
    int max_attempts = PUSH_TIMEOUT_SEC * (1000 / PUSH_POLL_INTERVAL_MS);
    
    // Send push notification
    snprintf(post_data, sizeof(post_data),
             "{\"stateToken\":\"%s\"}", state_token);
             
    curl_easy_setopt(curl, CURLOPT_URL, verify_endpoint);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);
    
    res = curl_easy_perform(curl);
    if (res != CURLE_OK) {
        debug_log("Failed to send push notification: %s", curl_easy_strerror(res));
        return PAM_AUTH_ERR;
    }
    
    // Poll for response
    for (int i = 0; i < max_attempts; i++) {
        chunk->size = 0;
        res = curl_easy_perform(curl);
        
        if (res != CURLE_OK) {
            debug_log("Push verification check failed: %s", curl_easy_strerror(res));
            return PAM_AUTH_ERR;
        }
        
        char* status = get_json_value(chunk->memory, "status");
        if (status) {
            if (strcmp(status, "SUCCESS") == 0) {
                return PAM_SUCCESS;
            } else if (strcmp(status, "REJECTED") == 0) {
                return PAM_AUTH_ERR;
            }
        }
        
        usleep(PUSH_POLL_INTERVAL_MS * 1000);
    }
    
    debug_log("Push verification timed out");
    return PAM_AUTH_ERR;
}

// Handle code-based verification (TOTP, SMS, Email)
static int handle_code_verification(pam_handle_t* pamh, CURL* curl,
                                  const char* state_token, const char* factor_id,
                                  struct MemoryStruct* chunk, const char* verify_endpoint) {
    CURLcode res;
    char* mfa_code = NULL;
    char post_data[MAX_LINE * 2];
    
    int ret = prompt_user(pamh, PAM_PROMPT_ECHO_ON,
                         "Enter your verification code: ", &mfa_code);
    if (ret != PAM_SUCCESS || !mfa_code) {
        debug_log("Failed to get verification code");
        return PAM_AUTH_ERR;
    }
    
    snprintf(post_data, sizeof(post_data),
             "{\"stateToken\":\"%s\",\"passCode\":\"%s\"}",
             state_token, mfa_code);
             
    memset(mfa_code, 0, strlen(mfa_code));
    free(mfa_code);
    
    curl_easy_setopt(curl, CURLOPT_URL, verify_endpoint);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);
    
    chunk->size = 0;
    res = curl_easy_perform(curl);
    
    if (res != CURLE_OK) {
        debug_log("Code verification failed: %s", curl_easy_strerror(res));
        return PAM_AUTH_ERR;
    }
    
    char* status = get_json_value(chunk->memory, "status");
    return (status && strcmp(status, "SUCCESS") == 0) ? PAM_SUCCESS : PAM_AUTH_ERR;
}

// Handle WebAuthn/FIDO2 verification
static int handle_webauthn_verification(pam_handle_t* pamh, CURL* curl,
                                      const char* state_token, const char* factor_id,
                                      struct MemoryStruct* chunk, const char* verify_endpoint) {
    debug_log("WebAuthn/FIDO2 authentication not yet supported");
    return PAM_AUTH_ERR;
}

// Main authentication function
static int authenticate_with_okta(pam_handle_t* pamh, const char* username, 
                                const char* password, struct OktaConfig* config) {
    debug_log("Starting Okta authentication for user: %s", username);
    
    CURL* curl;
    CURLcode res;
    struct MemoryStruct chunk;
    int ret = PAM_AUTH_ERR;

    chunk.memory = malloc(1);
    chunk.size = 0;

    curl = curl_easy_init();
    if (!curl) {
        debug_log("Failed to initialize CURL");
        free(chunk.memory);
        return PAM_SYSTEM_ERR;
    }

    // Initial authentication request
    char post_data[MAX_LINE * 3];
    snprintf(post_data, sizeof(post_data),
             "{\"username\":\"%s\",\"password\":\"%s\"}", username, password);

    struct curl_slist* headers = NULL;
    headers = curl_slist_append(headers, "Accept: application/json");
    headers = curl_slist_append(headers, "Content-Type: application/json");

    curl_easy_setopt(curl, CURLOPT_URL, config->auth_endpoint);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);

    debug_log("Sending authentication request");
    res = curl_easy_perform(curl);

    if (res != CURLE_OK) {
        debug_log("Authentication request failed: %s", curl_easy_strerror(res));
        ret = PAM_AUTH_ERR;
        goto cleanup;
    }

    char* status = get_json_value(chunk.memory, "status");
    if (!status) {
        debug_log("No status in response");
        ret = PAM_AUTH_ERR;
        goto cleanup;
    }

    if (strcmp(status, "SUCCESS") == 0) {
        debug_log("Authentication successful without MFA");
        ret = PAM_SUCCESS;
    } else if (strcmp(status, "MFA_REQUIRED") == 0) {
        debug_log("MFA required, processing MFA challenge");
        
        char* state_token = get_json_value(chunk.memory, "stateToken");
        if (!state_token) {
            debug_log("No state token found");
            ret = PAM_AUTH_ERR;
            goto cleanup;
        }
        
        // Parse available factors
        struct MFAFactors factors;
        if (parse_mfa_factors(chunk.memory, &factors) != 0) {
            debug_log("Failed to parse MFA factors");
            ret = PAM_AUTH_ERR;
            goto cleanup;
        }
        
        // Select factor if multiple available
        int selected_factor = factors.count > 1 ? 
            select_mfa_factor(pamh, &factors) : 0;
            
        if (selected_factor < 0) {
            debug_log("Invalid factor selection");
            ret = PAM_AUTH_ERR;
            goto cleanup;
        }
        
        // Get verification endpoint
        char verify_endpoint[MAX_LINE * 2];
        snprintf(verify_endpoint, sizeof(verify_endpoint),
                "%s/factors/%s/verify",
                config->auth_endpoint, factors.factors[selected_factor].id);
        
        // Handle different factor types
        const char* factor_type = factors.factors[selected_factor].type;
        
        if (strcmp(factor_type, "push") == 0) {
            ret = handle_push_verification(curl, state_token,
                                        factors.factors[selected_factor].id,
                                        &chunk, verify_endpoint);
        } else if (strcmp(factor_type, "token") == 0 ||
                   strcmp(factor_type, "sms") == 0 ||
                   strcmp(factor_type, "email") == 0) {
            ret = handle_code_verification(pamh, curl, state_token,
                                        factors.factors[selected_factor].id,
                                        &chunk, verify_endpoint);
        } else if (strcmp(factor_type, "webauthn") == 0) {
            ret = handle_webauthn_verification(pamh, curl, state_token,
                                            factors.factors[selected_factor].id,
                                            &chunk, verify_endpoint);
        } else {
            debug_log("Unsupported factor type: %s", factor_type);
            ret = PAM_AUTH_ERR;
        }
    } else {
        debug_log("Authentication failed with status: %s", status);
        ret = PAM_AUTH_ERR;
    }

cleanup:
    if (chunk.memory) free(chunk.memory);
    if (headers) curl_slist_free_all(headers);
    curl_easy_cleanup(curl);
    return ret;
}

// Main PAM authentication function
PAM_EXTERN int pam_sm_authenticate(pam_handle_t* pamh, int flags, int argc, const char** argv) {
    debug_log("Starting PAM Okta authentication module");
    
    char* okta_username = NULL;
    char* okta_password = NULL;
    int ret;
    struct OktaConfig config;

    // Read configuration
    if (read_config(&config) != 0) {
        debug_log("Failed to read Okta configuration");
        return PAM_IGNORE;
    }

    // Get Okta username
    ret = prompt_user(pamh, PAM_PROMPT_ECHO_ON,
                     "Okta username: ", &okta_username);
    if (ret != PAM_SUCCESS || !okta_username) {
        debug_log("Failed to get Okta username");
        return PAM_IGNORE;
    }

    // Get Okta password
    ret = prompt_user(pamh, PAM_PROMPT_ECHO_OFF,
                     "Okta password: ", &okta_password);
    if (ret != PAM_SUCCESS || !okta_password) {
        if (okta_username) {
            memset(okta_username, 0, strlen(okta_username));
            free(okta_username);
        }
        debug_log("Failed to get Okta password");
        return PAM_IGNORE;
    }

    // Authenticate with Okta
    ret = authenticate_with_okta(pamh, okta_username, okta_password, &config);

    // Clean up
    if (okta_username) {
        memset(okta_username, 0, strlen(okta_username));
        free(okta_username);
    }
    if (okta_password) {
        memset(okta_password, 0, strlen(okta_password));​​​​​​​​​​​​​​​​
