// Function to get JSON string values
static char* get_json_string(const char* json, const char* key) {
    static char value[MAX_LINE];
    char search_key[MAX_LINE];
    snprintf(search_key, sizeof(search_key), "\"%s\":\"", key);
    
    char* start = strstr(json, search_key);
    if (!start) {
        // Try without quotes
        snprintf(search_key, sizeof(search_key), "\"%s\":", key);
        start = strstr(json, search_key);
        if (!start) return NULL;
        
        start += strlen(search_key);
        while (*start == ' ' || *start == '\n' || *start == '\t') start++;
        
        if (*start == '"') {
            start++;
            char* end = strchr(start, '"');
            if (!end) return NULL;
            size_t len = end - start;
            if (len >= sizeof(value)) len = sizeof(value) - 1;
            strncpy(value, start, len);
            value[len] = '\0';
            return value;
        } else {
            // Handle non-string values
            char* end = start;
            while (*end && *end != ',' && *end != '}' && *end != ']') end++;
            size_t len = end - start;
            if (len >= sizeof(value)) len = sizeof(value) - 1;
            strncpy(value, start, len);
            value[len] = '\0';
            return value;
        }
    }
    
    start += strlen(search_key);
    char* end = strchr(start, '"');
    if (!end) return NULL;
    
    size_t len = end - start;
    if (len >= sizeof(value)) len = sizeof(value) - 1;
    strncpy(value, start, len);
    value[len] = '\0';
    
    return value;
}

// Function to prompt user
static int prompt_user(pam_handle_t* pamh, int msg_style, const char* prompt, char** response) {
    const struct pam_conv* conv;
    struct pam_message msg;
    struct pam_response* resp = NULL;
    const struct pam_message* pmsg[1];
    int ret;

    ret = pam_get_item(pamh, PAM_CONV, (const void**)&conv);
    if (ret != PAM_SUCCESS) {
        debug_log("Failed to get PAM conversation: %d", ret);
        return ret;
    }

    if (conv == NULL || conv->conv == NULL) {
        debug_log("PAM conversation is null");
        return PAM_SYSTEM_ERR;
    }

    msg.msg_style = msg_style;
    msg.msg = prompt;
    pmsg[0] = &msg;

    debug_log("Displaying prompt: %s", prompt);
    ret = conv->conv(1, pmsg, &resp, conv->appdata_ptr);
    debug_log("Conversation returned: %d", ret);

    if (ret != PAM_SUCCESS) {
        debug_log("Conversation failed: %d", ret);
        return ret;
    }

    if (resp == NULL) {
        debug_log("Response is null");
        return PAM_CONV_ERR;
    }

    if (resp[0].resp == NULL) {
        debug_log("Response string is null");
        free(resp);
        return PAM_CONV_ERR;
    }

    *response = strdup(resp[0].resp);
    debug_log("Got response (length: %zu)", strlen(resp[0].resp));

    memset(resp[0].resp, 0, strlen(resp[0].resp));
    free(resp[0].resp);
    free(resp);

    return PAM_SUCCESS;
}

// Read configuration
static int read_config(struct OktaConfig* config) {
    debug_log("Reading Okta configuration");
    
    FILE* fp = fopen(CONFIG_FILE, "r");
    if (!fp) {
        debug_log("Cannot open config file: %s", strerror(errno));
        return -1;
    }

    memset(config, 0, sizeof(struct OktaConfig));
    int found_endpoint = 0;

    char line[MAX_LINE];
    while (fgets(line, sizeof(line), fp)) {
        if (line[0] == '#' || line[0] == '\n') continue;
        
        // Remove trailing whitespace
        size_t len = strlen(line);
        while (len > 0 && (line[len-1] == '\n' || line[len-1] == '\r' || 
               line[len-1] == ' ' || line[len-1] == '\t')) {
            line[--len] = '\0';
        }
        
        char* key = strtok(line, "=");
        char* value = strtok(NULL, "");  // Get rest of line
        
        if (key && value) {
            // Trim leading whitespace from value
            while (*value == ' ') value++;
            
            if (strcmp(key, "auth_endpoint") == 0) {
                strncpy(config->auth_endpoint, value, MAX_LINE - 1);
                found_endpoint = 1;
                debug_log("Found auth_endpoint: %s", value);
            } else if (strcmp(key, "issuer") == 0) {
                strncpy(config->issuer, value, MAX_LINE - 1);
            } else if (strcmp(key, "client_id") == 0) {
                strncpy(config->client_id, value, MAX_LINE - 1);
            } else if (strcmp(key, "client_secret") == 0) {
                strncpy(config->client_secret, value, MAX_LINE - 1);
            }
        }
    }
    fclose(fp);

    if (!found_endpoint) {
        debug_log("No auth_endpoint found in config");
        return -1;
    }

    debug_log("Configuration loaded successfully");
    return 0;
}

// Parse MFA factors from response
static int parse_mfa_factors(const char* json_str, struct MFAFactors* factors) {
    debug_log("Starting to parse MFA factors");
    debug_log("Input JSON: %.200s...", json_str); // Log first 200 chars
    
    factors->count = 0;
    
    // Find _embedded section first
    char* embedded = find_json_section(json_str, "_embedded");
    if (!embedded) {
        debug_log("No _embedded section found");
        return -1;
    }
    
    // Find factors array
    char* factors_array = find_array_start(embedded, "factors");
    if (!factors_array) {
        debug_log("No factors array found");
        return -1;
    }
    
    debug_log("Found factors array");
    char* current = factors_array;
    char factor_buffer[MAX_LINE * 4];
    
    while (*current && factors->count < MAX_FACTORS) {
        // Skip whitespace and commas
        while (*current && (*current == ' ' || *current == ',' || 
               *current == '\n' || *current == '\t' || *current == '\r')) {
            current++;
        }
        
        if (*current == ']' || *current == '\0') break;
        
        // Extract the factor object
        char* next = extract_json_object(current, factor_buffer, sizeof(factor_buffer));
        if (!next) {
            debug_log("Failed to extract factor object");
            break;
        }
        
        debug_log("Extracted factor object: %s", factor_buffer);
        
        // Parse the factor object
        char* id = get_json_string(factor_buffer, "id");
        char* type = get_json_string(factor_buffer, "factorType");
        char* provider = get_json_string(factor_buffer, "provider");
        
        debug_log("Parsed factor - id: %s, type: %s, provider: %s",
                 id ? id : "null",
                 type ? type : "null",
                 provider ? provider : "null");
        
        if (id && type && provider) {
            strncpy(factors->factors[factors->count].id, id, MAX_LINE - 1);
            strncpy(factors->factors[factors->count].type, type, MAX_LINE - 1);
            strncpy(factors->factors[factors->count].provider, provider, MAX_LINE - 1);
            
            // Ensure null termination
            factors->factors[factors->count].id[MAX_LINE - 1] = '\0';
            factors->factors[factors->count].type[MAX_LINE - 1] = '\0';
            factors->factors[factors->count].provider[MAX_LINE - 1] = '\0';
            
            debug_log("Added factor #%d", factors->count + 1);
            factors->count++;
        } else {
            debug_log("Missing required fields in factor object");
        }
        
        current = next;
    }
    
    debug_log("Found %d factors", factors->count);
    return factors->count > 0 ? 0 : -1;
}
